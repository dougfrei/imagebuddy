{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","to","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","window","CustomEvent","event","params","evtParams","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","Event","ImageTools","opts","_classCallCheck","this","eventsRunning","elementCache","config","events","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","matchDPR","noHeight","resize","getElements","i","item","loaded","options","canLazyLoad","setupEventListeners","el","offsetTop","pageYOffset","innerHeight","eventName","callback","_this","addEventListener","requestAnimationFrame","dispatchEvent","throttleEventListener","resizeHandler","bind","scrollHandler","debug","_console","_console2","console","info","apply","_console3","table","foundEls","querySelectorAll","push","elType","toLowerCase","sizes","getSizes","getAttribute","debugInfo","style","display","getComputedStyle","width","displayStyle","clientWidth","height","container","getElementWidth","parentElement","rImgSources","split","map","sizeEl","_sizeEl$split","_sizeEl$split2","_slicedToArray","url","parseInt","sort","clientHeight","a","b","containerWidth","containerHeight","imageWidth","imageHeight","score","Math","abs","tagName","getContainerDimensions","devicePixelRatio","scoredSizes","size","_this2","calculateUsabilityScore","debugTable","idealImage","setAttribute","backgroundImage","chooseImage"],"mappings":"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","file":"imageTools.es5.min.js","sourcesContent":["/**\n * Object.assign polyfill for IE\n */\nif (typeof Object.assign != 'function') {\n\tObject.assign = function(target, varArgs) { // .length of function is 2\n\t\t'use strict';\n\n\t\tif (target === null) { // TypeError if undefined or null\n\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t\t}\n\n\t\tvar to = Object(target);\n\n\t\tfor (var index = 1; index < arguments.length; index++) {\n\t\t\tvar nextSource = arguments[index];\n\n\t\t\tif (nextSource !== null) { // Skip over if undefined or null\n\t\t\t\tfor (var nextKey in nextSource) {\n\t\t\t\t\t// Avoid bugs when hasOwnProperty is shadowed\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t};\n}\n\n/**\n * Event constructor polyfill for IE\n */\nif (typeof window.CustomEvent !== 'function') {\n\tconst CustomEvent = function(event, params) {\n\t\tconst evtParams = params || { bubbles: false, cancelable: false, detail: undefined };\n\t\tconst evt = document.createEvent('CustomEvent');\n\n\t\tevt.initCustomEvent(event, evtParams.bubbles, evtParams.cancelable, evtParams.detail);\n\n\t\treturn evt;\n\t};\n\n\tCustomEvent.prototype = window.Event.prototype;\n\n\twindow.CustomEvent = CustomEvent;\n}\n\n/**\n * ImageTools class\n */\nclass ImageTools {\n\t/**\n\t * Constructor\n\t *\n\t * @param {object} opts\n\t */\n\tconstructor(opts) {\n\t\tthis.eventsRunning = {};\n\t\tthis.elementCache = [];\n\n\t\tthis.config = {\n\t\t\tevents: {\n\t\t\t\tresize: 'imageToolsResize',\n\t\t\t\tscroll: 'imageToolsScroll'\n\t\t\t},\n\t\t\tattributes: {\n\t\t\t\t// enabled: 'data-it-enabled',\n\t\t\t\tsources: 'data-it-sources',\n\t\t\t\tlazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr',\n\t\t\t\tnoHeight: 'data-it-no-height'\n\t\t\t}\n\t\t};\n\n\t\tthis.opts = Object.assign({\n\t\t\tdebug: false,\n\t\t\tmatchDPR: true,\n\t\t\tlazyLoad: true,\n\t\t\tlazyLoadThreshold: 100\n\t\t}, opts);\n\n\t\t// const defaults = {\n\t\t// \tdebug: false,\n\t\t// \tmatchDPR: true,\n\t\t// \tlazyLoad: true,\n\t\t// \tlazyLoadThreshold: 100\n\t\t// };\n\n\t\t// this.opts = { ...defaults, ...opts };\n\n\t\tthis.setupEventListeners();\n\t\tthis.update();\n\t}\n\n\tupdate() {\n\t\tthis.getElements();\n\n\t\tfor (let i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && this.canLazyLoad(item) === false)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.chooseImage(item);\n\t\t}\n\t}\n\n\t/**\n\t * Test if an item is lazy load-able\n\t *\n\t * @param {object} item\n\t */\n\tcanLazyLoad(item) {\n\t\tif (!item.options.lazyLoad || item.loaded) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (item.el.offsetTop - (window.pageYOffset + window.innerHeight) <= item.options.lazyLoadThreshold) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Setup a throttled event listener\n\t *\n\t * @param {string} name\n\t * @param {function} callback\n\t */\n\tthrottleEventListener(eventName, callback) {\n\t\tif (!this.eventsRunning.hasOwnProperty(eventName)) {\n\t\t\tthis.eventsRunning[eventName] = false;\n\t\t}\n\n\t\twindow.addEventListener(eventName, () => {\n\t\t\tif (this.eventsRunning[eventName]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.eventsRunning[eventName] = true;\n\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\twindow.dispatchEvent(new CustomEvent(`${eventName}-throttled`));\n\t\t\t\tthis.eventsRunning[eventName] = false;\n\t\t\t});\n\t\t});\n\n\t\tif (typeof callback === 'function') {\n\t\t\twindow.addEventListener(`${eventName}-throttled`, callback);\n\t\t}\n\t}\n\n\t/**\n\t * Setup and throttle event listeners -- scroll & resize\n\t */\n\tsetupEventListeners() {\n\t\tthis.throttleEventListener('resize', this.resizeHandler.bind(this));\n\t\tthis.throttleEventListener('scroll', this.scrollHandler.bind(this));\n\t}\n\n\t/**\n\t * Print a debug message\n\t */\n\tdebug() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n\t\t}\n\t}\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n\t/**\n\t * Get all the HTML elements configured for image selection\n\t */\n\tgetElements() {\n\t\tthis.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (let i = 0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n\t\t\tthis.elementCache.push({\n\t\t\t\tel: el,\n\t\t\t\telType: el.tagName.toLowerCase(),\n\t\t\t\t// container: this.getContainerDimensions(el),\n\t\t\t\tsizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n\t\t\t\tloaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad).toLowerCase() === 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t\t\t\tnoHeight: el.getAttribute(this.config.attributes.noHeight) ? el.getAttribute(this.config.attributes.noHeight) : false\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.debugInfo(this.elementCache);\n\t}\n\n\t/**\n\t * Get container dimensions of an HTML element\n\t *\n\t * @param {object} el\n\t * @param {bool} noHeight\n\t */\n\tgetContainerDimensions(el, noHeight) {\n\t\t// FIXME:\n\t\t// this is tricky since an IMG tag may not have a set height and we can't rely on\n\t\t// its container for that height value\n\t\t// I'm thinking the best way to tackle this is to see if the element has a height\n\t\t// specified -- if not we'll disregard the height value\n\t\t//      - how does a 100% height work with this?\n\n\t\t// el.clientHeight works fine on all tags except IMG\n\n\t\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\t\tconst container = {\n\t\t\twidth: (displayStyle == 'block') ? el.clientWidth : 0,\n\t\t\theight: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n\t\t};\n\n\t\tif (!container.width) {\n\t\t\tcontainer.width = this.getElementWidth(el.parentElement);\n\t\t}\n\n\t\tif (noHeight) {\n\t\t\tcontainer.height = 0;\n\t\t}\n\n\t\treturn container;\n\t}\n\n\t/**\n\t * Return the width of a tested element\n\t * This will examine a style attribute tag first and fallback to the computed style\n\t * \n\t * @param {object} el \n\t */\n\tgetElementWidth(el) {\n\t\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\t\tif (displayStyle != 'block' && el.parentElement) {\n\t\t\treturn this.getElementWidth(el.parentElement);\n\t\t}\n\n\t\treturn el.clientWidth;\n\t}\n\n\t/**\n\t * Create an array of image sizes from the \"data-it-sources\" attribute\n\t *\n\t * @param {string} rImgSources\n\t */\n\tgetSizes(rImgSources) {\n\t\treturn rImgSources\n\t\t\t.split(';')\n\t\t\t.map(sizeEl => {\n\t\t\t\tconst [url, width, height] = sizeEl.split(',');\n\t\t\t\treturn { url: url, width: parseInt(width), height: parseInt(height) };\n\t\t\t})\n\t\t\t.sort((a, b) => {\n\t\t\t\tif (a.width >= a.height) {\n\t\t\t\t\treturn a.width > b.width ? 1 : -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn a.height > b.height ? 1 : -1;\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tthis.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth - imageWidth);\n\t\t}\n\n\t\tif (containerHeight) {\n\t\t\tif (imageHeight >= containerHeight) {\n\t\t\t\tscore *= containerHeight / imageHeight;\n\t\t\t} else {\n\t\t\t\tscore -= Math.abs(containerHeight - imageHeight);\n\t\t\t}\n\t\t}\n\n\t\t// const isLandscape = containerWidth > containerHeight;\n\t\t\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n\t/**\n\t * Choose the appropriate image and apply it to the element\n\t *\n\t * @param {object} item\n\t */\n\tchooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n\t\tconst elType = item.el.tagName.toLowerCase();\n\n\t\tconst container = this.getContainerDimensions(item.el, item.options.noHeight);\n\n\t\tif (item.options.matchDPR) {\n\t\t\tcontainer.width *= window.devicePixelRatio;\n\t\t\tcontainer.height *= window.devicePixelRatio;\n\t\t}\n\n\t\tconst scoredSizes = sizes.map((size) => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n\t\tconst idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n\t\tif (elType === 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n\t\titem.loaded = true;\n\t}\n\n\t/**\n\t * Resize handler\n\t */\n\tresizeHandler() {\n\t\t// update container sizes\n\t\tthis.debug('resizeHandler');\n\t}\n\n\t/**\n\t * Scroll handler -- check for lazy load-able images\n\t */\n\tscrollHandler() {\n\t\t// lazy load images\n\t\tfor (let i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.debugInfo('choosing image', item);\n\n\t\t\tthis.chooseImage(item);\n\t\t}\n\t}\n}\n"]}