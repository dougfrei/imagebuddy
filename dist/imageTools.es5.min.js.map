{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","to","CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","window","Event","ImageTools","opts","_classCallCheck","this","eventsRunning","elementCache","config","resize","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","matchDPR","getElements","debug","i","item","options","canLazyLoad","update","loaded","el","offsetTop","pageYOffset","innerHeight","eventName","_this","addEventListener","requestAnimationFrame","dispatchEvent","callback","throttleEventListener","resizeHandler","bind","scrollHandler","_console3","console","table","apply","foundEls","querySelectorAll","push","elType","tagName","toLowerCase","sizes","getSizes","log","getAttribute","noHeight","debugInfo","displayStyle","style","display","getComputedStyle","container","width","height","clientHeight","parentElement","getElementWidth","clientWidth","rImgSources","split","map","sizeEl","_sizeEl$split","_sizeEl$split2","_slicedToArray","url","parseInt","a","b","containerHeight","imageWidth","imageHeight","containerWidth","score","Math","abs","_this2","getContainerDimensions","isLandscape","devicePixelRatio","scoredSizes","size","calculateUsabilityScore","sort","debugTable","setAttribute","idealImage","backgroundImage"],"mappings":"+yBAG4B,mBAAjBA,QAAOC,SACdD,OAAOC,OAAS,SAASC,EAAQC,GAG7B,GAAe,OAAXD,EAPZ,KAAA,IAAAE,WAAA,6CAIgD,KAAA,GADrCJ,GAAAA,OAAPE,GAC4CG,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAA,CACxC,GAAAG,GAAAF,UAAAD,EAEIH,IAAiB,OAAjBA,EAAmB,IAAA,GAAAO,KAAAD,GAEtBR,OAAAU,UAAAC,eAAAC,KAAAJ,EAAAC,KAWeI,EAAGJ,GAAWD,EAAWC,IAJrC,MAAAI,KAMK,WAIT,QAAAC,GAAAC,EAAAC,GAtBJA,EAAAA,IAAAC,SAAA,EAAAC,YAAA,EAAAC,WAAAC,GAwBH,IAAAC,GAAAC,SAAAC,YAAA,cAcO,OAFAF,GAAIG,gBAAgBT,EAAOC,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAE9DE,EAnBF,GAAA,kBAAAI,QAAAX,YACJ,OAAA,CAULA,GAAWW,UAAOX,OAAdY,MAA8BhB,UAGlCe,OAAAX,YAAqBC,QAMpBY,uBAgBD,QAAAA,GAAYC,GAAMC,gBAAAC,KAAAH,GATtBG,KAAAC,iBAWQD,KAAKE,gBAELF,KAAKG,QAVPN,QACFO,OAAA,mBAYYC,OAAQ,oBAEZC,YATRC,QAAYT,kBAAMU,SAAA,mBAalBC,kBAAmB,6BAZfC,SAAKT,oBACAC,SAAL,sBAIQE,KAAAA,KAAAA,OAAQjC,QACRkC,OAAAA,EAFIK,UADE,EAKVJ,UAAAA,EACIG,kBAAA,KACAF,GAEZE,KAAAA,sBACAC,KAAAA,+DAiBIV,KAAKW,aAXDC,KAAAA,GAAAA,GAAO,EADeC,EAAAb,KAAAE,aAAAzB,OAAAoC,IAAA,CAEtBH,GAAAA,GAAAA,KAAAA,aAFsBG,EAItBJ,GAAAA,QAAmBK,EAAAC,QAAAP,WAAA,IAAAR,KAAAgB,YAAAF,IAI7Bd,KAAKiB,YAALH,wCAOCA,GAgBK,SAAKA,EAAKC,QAAQP,UAAYM,EAAKI,SAI/BJ,EAAKK,GAAGC,WAAazB,OAAO0B,YAAc1B,OAAO2B,cAAgBR,EAAKC,QAAQN,gEAahEc,EAlBVT,GAAM,GAAAU,GAAAxB,IACdA,MAAKc,cAAaN,eAAiBU,KAC/BlB,KAAAC,cAAAsB,IAAA,GAGJ5B,OAAA8B,iBAAYL,EAAazB,WACrB6B,EAAAvB,cAAAsB,KAIPC,EAAAvB,cAAAsB,IAAA,EAEDG,sBAAA,WAmBY/B,OAAOgC,cAAc,GAAI3C,aAAYuC,EAAU,eAC/CC,EAAKvB,cAAcsB,IAAa,OAIjB,kBAAZK,IACPjC,OAAO8B,iBAAiBF,EAAU,aAAcK,iDAQpD5B,KAAK6B,sBAAsB,SAAU7B,KAAK8B,cAAcC,KAAK/B,OAtB7DL,KAAAA,sBAAA,SAAAK,KAAmCgC,cAAMD,KAAA/B,uCAOrC0B,GAAAA,KAAAA,KAAAA,MAAAA,CAAAA,GAAAA,IACI/B,EAAAA,SAAAA,IAAAA,MAAAA,EAAAA,gDAKR,GAAAK,KAAAF,KAAIc,MAAOgB,CAAAA,GAAAA,IACPjC,EAAAA,SAAAA,KAAAA,MAAAA,EAAAA,iDA4BV,GAAIK,KAAKF,KAAKc,MAAO,CAAA,GAAAqB,IACpBA,EAAAC,SAAQC,MAARC,MAAAH,EAAiBzD,kDAQZwB,KAAKE,eAIX,KAAK,GAFCmC,GAAW7C,SAAS8C,iBAAT,IAA8BtC,KAAKG,OAAOG,WAAWC,QAArD,KAERM,EAAG,EAAGA,EAAIwB,EAAS5D,OAAQoC,IAAK,CACxC,GAAMM,GAAKkB,EAASxB,EAEXb,MAAKE,aAAaqC,MA5BlBpB,GAAAA,EAAiBqB,OAAArB,EAAAsB,QAAAC,cAC1BC,MAAA3C,KAAA4C,SAAQC,EAARC,aAAA9C,KAAexB,OAAAA,WAAf+B,UACMW,QAAA,EACJH,SAgCAP,SAAUW,EAAG2B,aAAa9C,KAAKG,OAAOG,WAAWE,UAAgE,QAApDW,EAAG2B,aAAa9C,KAAKG,OAAOG,WAAWE,UAAsBR,KAAKF,KAAKU,SACpIC,kBAAmBU,EAAG2B,aAAa9C,KAAKG,OAAOG,WAAWG,mBAAqBU,EAAG2B,aAAa9C,KAAKG,OAAOG,WAAWG,mBAAqBT,KAAKF,KAAKW,kBACrJC,SAAUS,EAAG2B,aAAa9C,KAhClBG,OAAAG,WAAAI,UAAAS,EAAA2B,aAAA9C,KAAAG,OAAAG,WAAAI,UAAAV,KAAAF,KAAAY,SACPqC,WAAUnC,EAAOkC,aAAA9C,KAAAG,OAAAG,WAAAyC,WAAA5B,EAAA2B,aAAA9C,KAAAG,OAAAG,WAAAyC,aAGrB/C,KAAAgD,UAAAhD,KAAAE,6DAMAiB,EAAA4B,GA+CM,GAAME,GAAe9B,EAAG+B,MAAMC,QAAUhC,EAAG+B,MAAMC,QAAUxD,OAAOyD,iBAAiBjC,GAAIgC,QAEnFE,GAvCVC,MAAmBjB,SAAdY,EAAL9B,EAAoCN,YAAK,EACxC0C,OAAMpC,EAAAA,aAANA,EAAAqC,aAAA,EAWE9C,OARWS,GAAAA,QACAqB,EAAAA,MAAQrB,KAAGsB,gBAAHtB,EAFWsC,gBAKnBvC,IACZH,EAAAA,OAAS,GAGRL,0CASDS,GA2CI,MAAoB,UAFCA,EAAG+B,MAAMC,QAAUhC,EAAG+B,MAAMC,QAAUxD,OAAOyD,iBAAiBjC,GAAIgC,UAExDhC,EAAGsC,cACvBzD,KAAK0D,gBAAgBvC,EAAGsC,eAG5BtC,EAAGwC,6CAnCVC,GA4CA,MAAOA,GA1CPC,MAAA,KA4CKC,IAAI,SAAAC,GAAU,GAAAC,GA1CWb,EAAUhC,MAAA,KA0CrB8C,EAAAC,eAAAF,EAAA,GA1Cbf,EA0CagB,EAAA,GA1CbhB,EA0CagB,EAAA,GA1CKf,EA0CLe,EAAA,EAEX,QAASE,IAAKA,EAAKb,MAAOc,SAASd,GAAQC,OAAQa,SAASb,MAzChED,KAAAA,SAAAA,EAAAA,GACAC,MAAAA,GAAAA,OAAWC,EAAAA,OAFfa,EAAAf,MAAAgB,EAAAhB,MAAA,GAAA,EAKeA,EAAAA,OAAOgB,EAAAf,OAAA,GAAA,oDAKlBF,EAAAkB,EAAAC,EAAAC,GAGJzE,KAAAY,MAAA,cAAA8D,EAAA,IAAAH,EAAA,UAAAC,EAAA,IAAAC,EA6CN,IAAIE,GAAQ,CAlBa,OAoBrBH,IAAcE,EACjBC,GAASD,EAAiBF,EAE1BG,GAASC,KAAKC,IAAIH,EAAeF,GAGxBD,IACIE,GAAeF,EACfI,GAASJ,EAAkBE,EAE3BE,GAASC,KAAKC,IAAIN,EAAgBE,IA9BvBE,sCAQP7D,GAAA,GAAAgE,GAAA9E,KACH2C,EAAA3C,KAAA4C,SAAA9B,EAAAK,GAAA2B,aAAA9C,KAAAG,OAAAG,WAAAC,UAXTiC,EAAA1B,EAAAK,GAAAsB,QAAAC,cAiEMW,EAAYrD,KAAK+E,uBAAuBjE,EAAKK,GAAIL,EAAKC,QAAQgC,SAEtEjC,GAAKC,QAAQL,WAnDjB2C,EAAM2B,OAAcN,OAAAA,iBAqDVrB,EAAUE,QAAU5D,OAAOsF,iBAjDrC,IAAAC,GAAIP,EAAJb,IAAA,SAAAqB,GAGCR,MAkDAQ,GAAKR,MAAQG,EAAKM,wBAAwB/B,EAAUC,MAAOD,EAAUE,OAAQ4B,EAAK7B,MAAO6B,EAAK5B,QAlD9FoB,GAGAO,GAAAG,KAAA,SAAAhB,EAAAC,GAAA,MAAAD,GAAAM,MAAAL,EAAAK,QAEK3E,KAAAsF,WAAIf,EAEII,IAAAA,GAAAA,EAASJ,EAAkBE,OAAAA,EAE3BE,MAAAA,MAAAA,GAEP,OAAAnC,EAqDN1B,EAAKK,GAAGoE,aAAa,MAAOC,EAAWrB,KAhDxCrD,EAAAK,GAAA+B,MAAAuC,gBAAA,QAAAD,EAAArB,IAAA,KAGArD,EAAAI,QAAA,0CA0DMlB,KAAKY,MAAM,yDAQjB,IAAK,GAAIC,GAAI,EAAGA,EAAIb,KAAKE,aAAazB,OAAQoC,IAAK,CAClD,GAAMC,GAAOd,KAAKE,aAAaW,EAE3BC,GAAKI,QAAWJ,EAAKC,QAAQP,WAAaR,KAAKgB,YAAYF,KAlD5Cd,KAAAgD,UAAA,iBAAAlC,GACpBd,KAAM2C,YAAaC","file":"imageTools.es5.min.js","sourcesContent":["/**\n * Object.assign polyfill for IE\n */\nif (typeof Object.assign != 'function') {\n    Object.assign = function(target, varArgs) { // .length of function is 2\n        'use strict';\n        \n        if (target === null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var to = Object(target);\n\n        for (var index = 1; index < arguments.length; index++) {\n            var nextSource = arguments[index];\n\n            if (nextSource !== null) { // Skip over if undefined or null\n                for (var nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n\n        return to;\n    };\n}\n\n/**\n * Event constructor polyfill for IE\n */\n(function () {\n    if (typeof window.CustomEvent === 'function')\n        return false;\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        \n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n})();\n\n/**\n * ImageTools class\n */\nclass ImageTools {\n    /**\n     * Constructor\n     *\n     * @param {object} opts\n     */\n    constructor(opts) {\n        this.eventsRunning = {};\n        this.elementCache = [];\n\n        this.config = {\n            events: {\n                resize: 'imageToolsResize',\n                scroll: 'imageToolsScroll'\n            },\n            attributes: {\n                // enabled: 'data-it-enabled',\n                sources: 'data-it-sources',\n                lazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr',\n                noHeight: 'data-it-no-height'\n            }\n        };\n\n        this.opts = Object.assign({\n            debug: false,\n            matchDPR: true,\n            lazyLoad: true,\n            lazyLoadThreshold: 100\n        }, opts);\n\n        this.setupEventListeners();\n\t\tthis.update();\n    }\n\n\tupdate() {\n        this.getElements();\n\n        for (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n            if (item.loaded || (item.options.lazyLoad && this.canLazyLoad(item) === false)) {\n                continue;\n            }\n\n            this.chooseImage(item);\n\t\t}\n\t}\n\n    /**\n     * Test if an item is lazy load-able\n     *\n     * @param {object} item\n     */\n    canLazyLoad(item) {\n        if (!item.options.lazyLoad || item.loaded) {\n            return false;\n        }\n\n        if (item.el.offsetTop - (window.pageYOffset + window.innerHeight) <= item.options.lazyLoadThreshold) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Setup a throttled event listener\n     *\n     * @param {string} name\n     * @param {function} callback\n     */\n    throttleEventListener(eventName, callback) {\n        if (!this.eventsRunning.hasOwnProperty(eventName)) {\n            this.eventsRunning[eventName] = false;\n        }\n\n        window.addEventListener(eventName, () => {\n            if (this.eventsRunning[eventName]) {\n                return;\n            }\n\n            this.eventsRunning[eventName] = true;\n\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent(eventName+'-throttled'));\n                this.eventsRunning[eventName] = false;\n            });\n        });\n\n        if (typeof callback == 'function') {\n            window.addEventListener(eventName+'-throttled', callback);\n        }\n    }\n\n    /**\n     * Setup and throttle event listeners -- scroll & resize\n     */\n    setupEventListeners() {\n        this.throttleEventListener('resize', this.resizeHandler.bind(this));\n        this.throttleEventListener('scroll', this.scrollHandler.bind(this));\n    }\n\n    /**\n     * Print a debug message\n     */\n    debug() {\n        if (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n        }\n    }\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n    /**\n     * Get all the HTML elements configured for image selection\n     */\n    getElements() {\n        this.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (var i =0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n            this.elementCache.push({\n                el: el,\n                elType: el.tagName.toLowerCase(),\n                // container: this.getContainerDimensions(el),\n                sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n                loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n                    noHeight: el.getAttribute(this.config.attributes.noHeight) ? el.getAttribute(this.config.attributes.noHeight) : false\n\t\t\t\t}\n            });\n\t\t}\n\n        this.debugInfo(this.elementCache);\n    }\n\n    /**\n     * Get container dimensions of an HTML element\n     *\n     * @param {object} el\n     * @param {bool} noHeight\n     */\n    getContainerDimensions(el, noHeight) {\n        // FIXME:\n        // this is tricky since an IMG tag may not have a set height and we can't rely on\n        // its container for that height value\n        // I'm thinking the best way to tackle this is to see if the element has a height\n        // specified -- if not we'll disregard the height value\n        //      - how does a 100% height work with this?\n\n        // el.clientHeight works fine on all tags except IMG\n\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        let container = {\n            width: (displayStyle == 'block') ? el.clientWidth : 0,\n            height: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n        };\n\n        if (!container.width) {\n            container.width = this.getElementWidth(el.parentElement);\n        }\n\n        if (noHeight) {\n            container.height = 0;\n        }\n\n        return container;\n    }\n\n    /**\n     * Return the width of a tested element\n     * This will examine a style attribute tag first and fallback to the computed style\n     * \n     * @param {object} el \n     */\n    getElementWidth(el) {\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        if (displayStyle != 'block' && el.parentElement) {\n            return this.getElementWidth(el.parentElement);\n        }\n\n        return el.clientWidth;\n    }\n\n    /**\n     * Create an array of image sizes from the \"data-it-sources\" attribute\n     *\n     * @param {string} rImgSources\n     */\n    getSizes(rImgSources) {\n        return rImgSources\n            .split(';')\n            .map(sizeEl => {\n                const [url, width, height] = sizeEl.split(',');\n                return { url: url, width: parseInt(width), height: parseInt(height) };\n            })\n            .sort((a, b) => {\n                if (a.width >= a.height) {\n                    return a.width > b.width ? 1 : -1;\n                } else {\n                    return a.height > b.height ? 1 : -1;\n                }\n            });\n    }\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tconst isLandscape = containerWidth > containerHeight;\n\n        this.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth-imageWidth);\n\t\t}\n\n        if (containerHeight) {\n            if (imageHeight >= containerHeight) {\n                score *= containerHeight / imageHeight;\n            } else {\n                score -= Math.abs(containerHeight-imageHeight);\n            }\n        }\n\n\n\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n    /**\n     * Choose the appropriate image and apply it to the element\n     *\n     * @param {object} item\n     */\n    chooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n        const elType = item.el.tagName.toLowerCase();\n\n        const container = this.getContainerDimensions(item.el, item.options.noHeight);\n        \n\t\tif (item.options.matchDPR) {\n            container.width *= window.devicePixelRatio;\n            container.height *= window.devicePixelRatio;\n        }\n\n\t\tlet scoredSizes = sizes.map(size => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n        let idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n        if (elType == 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n        item.loaded = true;\n    }\n\n    /**\n     * Resize handler\n     */\n    resizeHandler() {\n        // update container sizes\n        this.debug('resizeHandler');\n    }\n\n    /**\n     * Scroll handler -- check for lazy load-able images\n     */\n    scrollHandler() {\n        // lazy load images\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n            \tcontinue;\n            }\n\n            this.debugInfo('choosing image', item);\n\t\t\t\n            this.chooseImage(item);\n        }\n    }\n}\n"]}