{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","to","CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","window","Event","ImageTools","opts","_classCallCheck","this","elementCache","events","resize","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","eventsRunning","matchDPR","i","item","console","info","loaded","options","canLazyLoad","chooseImage","el","offsetTop","scrollY","innerHeight","eventName","callback","_this","addEventListener","requestAnimationFrame","dispatchEvent","resizeHandler","bind","throttleEventListener","scrollHandler","_console","log","apply","_console2","debug","_console3","table","foundEls","querySelectorAll","config","elType","tagName","toLowerCase","container","getContainerDimensions","sizes","getSizes","getAttribute","debugInfo","displayStyle","style","display","getComputedStyle","clientWidth","height","clientHeight","width","getElementWidth","parentElement","rImgSources","split","map","sizeEl","_sizeEl$split","_sizeEl$split2","_slicedToArray","url","parseInt","sort","a","b","containerWidth","containerHeight","imageWidth","imageHeight","score","Math","abs","_this2","devicePixelRatio","scoredSizes","size","debugTable","idealImage","setAttribute","backgroundImage"],"mappings":"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","file":"imageTools.es5.min.js","sourcesContent":["// Object.assign polyfill for IE\nif (typeof Object.assign != 'function') {\n    Object.assign = function(target, varArgs) { // .length of function is 2\n        'use strict';\n        \n        if (target === null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var to = Object(target);\n\n        for (var index = 1; index < arguments.length; index++) {\n            var nextSource = arguments[index];\n\n            if (nextSource !== null) { // Skip over if undefined or null\n                for (var nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n\n        return to;\n    };\n}\n\n// Event constructor polyfill for IE\n(function () {\n    if (typeof window.CustomEvent === 'function')\n        return false;\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        \n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n})();\n\nclass ImageTools {\n    /**\n     * Constructor\n     *\n     * @param {object} opts\n     */\n    constructor(opts) {\n        this.eventsRunning = {};\n        this.elementCache = [];\n\n        this.config = {\n            events: {\n                resize: 'imageToolsResize',\n                scroll: 'imageToolsScroll'\n            },\n            attributes: {\n                // enabled: 'data-it-enabled',\n                sources: 'data-it-sources',\n                lazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr'\n            }\n        };\n\n        this.opts = Object.assign({\n            debug: false,\n            matchDPR: true,\n            lazyLoad: true,\n            lazyLoadThreshold: 100\n        }, opts);\n\n        this.setupEventListeners();\n\t\tthis.update();\n    }\n\n\tupdate() {\n        this.getElements();\n\n\t\t// this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     this.chooseImage(item);\n        // });\n\n        for (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n            console.info('loaded', item.loaded);\n            \n            // FIXME: why does IE11 return true here for all images?\n            if (item.loaded || (item.options.lazyLoad && this.canLazyLoad(item) === false)) {\n                console.info('skipping');\n                continue;\n            }\n\n            this.chooseImage(item);\n\t\t}\n\t}\n\n    /**\n     * Loop through the current element cache and choose images\n     */\n    // processElementCache() {\n    //     this.elementCache.forEach(item => {\n    //         if (item.loaded || (item.lazyLoad && !this.canLazyLoad(item))) {\n    //             return;\n    //         }\n\t//\n    //         this.chooseImage(item);\n    //     });\n    // }\n\n    /**\n     * Test if an item is lazy load-able\n     *\n     * @param {object} item\n     */\n    canLazyLoad(item) {\n        if (!item.options.lazyLoad || item.loaded) {\n            return false;\n        }\n\n        // if (item.el.offsetTop - (window.scrollY + window.innerHeight) <= this.opts.lazyLoadThreshold) {\n\t\tif (item.el.offsetTop - (window.scrollY + window.innerHeight) <= item.options.lazyLoadThreshold) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Setup a throttled event listener\n     *\n     * @param {string} name\n     * @param {function} callback\n     */\n    throttleEventListener(eventName, callback) {\n        if (!this.eventsRunning.hasOwnProperty(eventName)) {\n            this.eventsRunning[eventName] = false;\n        }\n\n        window.addEventListener(eventName, () => {\n            if (this.eventsRunning[eventName]) {\n                return;\n            }\n\n            this.eventsRunning[eventName] = true;\n\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent(eventName+'-throttled'));\n                this.eventsRunning[eventName] = false;\n            });\n        });\n\n        if (typeof callback == 'function') {\n            window.addEventListener(eventName+'-throttled', callback);\n        }\n    }\n\n    /**\n     * Setup and throttle event listeners -- scroll & resize\n     */\n    setupEventListeners() {\n        this.throttleEventListener('resize', this.resizeHandler.bind(this));\n        this.throttleEventListener('scroll', this.scrollHandler.bind(this));\n    }\n\n    /**\n     * Print a debug message\n     */\n    debug() {\n        if (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n        }\n    }\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n    /**\n     * Get all the HTML elements configured for image selection\n     */\n    getElements() {\n        this.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (var i =0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n            this.elementCache.push({\n                el: el,\n                elType: el.tagName.toLowerCase(),\n                container: this.getContainerDimensions(el),\n                sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n                // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n                loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t\t\t}\n            });\n\t\t}\n\n        console.info(this.opts.lazyLoad);\n        console.info(this.elementCache);\n\n        // document.querySelectorAll(`[${this.config.attributes.sources}]`).forEach((el) => {\n        //     this.elementCache.push({\n        //         el: el,\n        //         elType: el.tagName.toLowerCase(),\n        //         container: this.getContainerDimensions(el),\n        //         sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n        //         // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n        //         loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t// \t\toptions: {\n\t\t// \t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t// \t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t// \t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t// \t\t}\n        //     });\n        // });\n\n        this.debugInfo(this.elementCache);\n    }\n\n    /**\n     * Get container dimensions of an HTML element\n     *\n     * @param {object} el\n     */\n    getContainerDimensions(el) {\n        // FIXME:\n        // this is tricky since an IMG tag may not have a set height and we can't rely on\n        // its container for that height value\n        // I'm thinking the best way to tackle this is to see if the element has a height\n        // specified -- if not we'll disregard the height value\n        //      - how does a 100% height work with this?\n\n        // el.clientHeight works fine on all tags except IMG\n\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        let container = {\n            width: (displayStyle == 'block') ? el.clientWidth : 0,\n            height: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n        };\n\n        if (!container.width) {\n            container.width = this.getElementWidth(el.parentElement);\n        }\n\n        // console.log('height', window.getComputedStyle(el).height, parseInt(window.getComputedStyle(el).height));\n        // console.log(displayStyle, container, el.clientHeight);\n\n        return container;\n\n\t\t\n        // console.log(`displayStyle: ${displayStyle}`);\n        \n\n\t\t// if (displayStyle != 'block' && el.parentElement) {\n\t\t// \tcontainer = this.getContainerDimensions(el.parentElement);\n\t\t// } else {\n\t\t// \tcontainer.width = el.clientWidth;\n\t\t// \tcontainer.height = el.clientHeight;\n\t\t// }\n\n\t\t// // switch (el.tagName.toLowerCase()) {\n\t\t// // \tcase 'section':\n\t\t// // \tcase 'div':\n\t\t// // \t\tcontainer.width = el.clientWidth;\n\t\t// // \t\tcontainer.height = el.clientHeight;\n\t\t// // \t\tbreak;\n\t\t// //\n\t\t// // \tdefault:\n\t\t// // \t\tif (el.parentElement) {\n\t\t// // \t\t\tcontainer = this.getContainerDimensions(el.parentElement);\n\t\t// // \t\t}\n\t\t// //\n\t\t// // \t\tbreak;\n\t\t// // }\n\n        // return container;\n    }\n\n    getElementWidth(el) {\n        // console.log('getting parent element width', el.tagName.toLowerCase());\n\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        if (displayStyle != 'block' && el.parentElement) {\n            return this.getElementWidth(el.parentElement);\n        }\n\n        return el.clientWidth;\n    }\n\n    /**\n     * Create an array of image sizes from the \"data-it-sources\" attribute\n     *\n     * @param {string} rImgSources\n     */\n    getSizes(rImgSources) {\n        return rImgSources\n            .split(';')\n            .map(sizeEl => {\n                const [url, width, height] = sizeEl.split(',');\n                return { url: url, width: parseInt(width), height: parseInt(height) };\n            })\n            .sort((a, b) => {\n                if (a.width >= a.height) {\n                    return a.width > b.width ? 1 : -1;\n                } else {\n                    return a.height > b.height ? 1 : -1;\n                }\n            });\n    }\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tconst isLandscape = containerWidth > containerHeight;\n\n        this.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth-imageWidth);\n\t\t}\n\n        if (containerHeight) {\n            if (imageHeight >= containerHeight) {\n                score *= containerHeight / imageHeight;\n            } else {\n                score -= Math.abs(containerHeight-imageHeight);\n            }\n        }\n\n\n\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n    /**\n     * Choose the appropriate image and apply it to the element\n     *\n     * @param {object} item\n     */\n    chooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n        const elType = item.el.tagName.toLowerCase();\n\n        const container = this.getContainerDimensions(item.el);\n\n\t\t// if (this.opts.matchDPR) {\n\t\tif (item.options.matchDPR) {\n            container.width *= window.devicePixelRatio;\n            container.height *= window.devicePixelRatio;\n        }\n\n\t\t// let possibleSizes = sizes.filter(function(size) {\n\t\t// \treturn size.width >= container.width && size.height >= container.height;\n        // });\n\n\t\tlet scoredSizes = sizes.map(size => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n        let idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n        console.info(`setting image: ${idealImage.url}`);\n\n\t\tif (elType == 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n        item.loaded = true;\n    }\n\n    /**\n     * Resize handler\n     */\n    resizeHandler() {\n        // update container sizes\n        this.debug('resizeHandler');\n    }\n\n    /**\n     * Scroll handler -- check for lazy load-able images\n     */\n    scrollHandler() {\n        // lazy load images\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n            \tcontinue;\n            }\n\n            // this.debugInfo('choosing image', item);\n\t\t\tconsole.info('lazy loading', item);\n            this.chooseImage(item);\n\t\t}\n\n        // this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     // this.debugInfo('choosing image', item);\n\t\t// \tconsole.log('lazy loading', item);\n        //     this.chooseImage(item);\n        // });\n    }\n}\n"]}