{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","to","index","nextSource","arguments","hasOwnProperty","call","nextKey","ImageTools","opts","_classCallCheck","this","eventsRunning","elementCache","config","events","resize","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","matchDPR","getElements","update","i","length","item","loaded","options","canLazyLoad","chooseImage","el","offsetTop","window","scrollY","innerHeight","eventName","callback","_this","addEventListener","requestAnimationFrame","dispatchEvent","CustomEvent","throttleEventListener","resizeHandler","bind","scrollHandler","debug","_console","_console2","console","info","apply","_console3","table","foundEls","document","querySelectorAll","push","tagName","toLowerCase","container","getContainerDimensions","sizes","getSizes","getAttribute","debugInfo","width","display","parentElement","rImgSources","split","map","sizeEl","_sizeEl$split","_sizeEl$split2","_slicedToArray","url","height","parseInt","b","a","containerWidth","containerHeight","imageWidth","imageHeight","score","Math","abs","elType","devicePixelRatio","isLandscape","size","_this2","calculateUsabilityScore","debugTable","scoredSizes","idealImage","setAttribute","style","backgroundImage"],"mappings":"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","file":"imageTools.es5.min.js","sourcesContent":["if (typeof Object.assign != 'function') {\n  Object.assign = function(target, varArgs) { // .length of function is 2\n    'use strict';\n    if (target == null) { // TypeError if undefined or null\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var to = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var nextSource = arguments[index];\n\n      if (nextSource != null) { // Skip over if undefined or null\n        for (var nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  };\n}\n\nclass ImageTools {\n    /**\n     * Constructor\n     *\n     * @param {object} opts\n     */\n    constructor(opts) {\n        this.eventsRunning = {};\n        this.elementCache = [];\n\n        this.config = {\n            events: {\n                resize: 'imageToolsResize',\n                scroll: 'imageToolsScroll'\n            },\n            attributes: {\n                // enabled: 'data-it-enabled',\n                sources: 'data-it-sources',\n                lazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr'\n            }\n        };\n\n        this.opts = Object.assign({\n            debug: false,\n            matchDPR: true,\n            lazyLoad: false,\n            lazyLoadThreshold: 100\n        }, opts);\n\n        this.setupEventListeners();\n\t\tthis.update();\n    }\n\n\tupdate() {\n\t\tthis.getElements();\n\n\t\t// this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     this.chooseImage(item);\n        // });\n\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t    if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n                continue;\n            }\n\n            this.chooseImage(item);\n\t\t}\n\t}\n\n    /**\n     * Loop through the current element cache and choose images\n     */\n    // processElementCache() {\n    //     this.elementCache.forEach(item => {\n    //         if (item.loaded || (item.lazyLoad && !this.canLazyLoad(item))) {\n    //             return;\n    //         }\n\t//\n    //         this.chooseImage(item);\n    //     });\n    // }\n\n    /**\n     * Test if an item is lazy load-able\n     *\n     * @param {object} item\n     */\n    canLazyLoad(item) {\n        if (!item.options.lazyLoad || item.loaded) {\n            return false;\n        }\n\n        // if (item.el.offsetTop - (window.scrollY + window.innerHeight) <= this.opts.lazyLoadThreshold) {\n\t\tif (item.el.offsetTop - (window.scrollY + window.innerHeight) <= item.options.lazyLoadThreshold) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Setup a throttled event listener\n     *\n     * @param {string} name\n     * @param {function} callback\n     */\n    throttleEventListener(eventName, callback) {\n        if (!this.eventsRunning.hasOwnProperty(eventName)) {\n            this.eventsRunning[eventName] = false;\n        }\n\n        window.addEventListener(eventName, () => {\n            if (this.eventsRunning[eventName]) {\n                return;\n            }\n\n            this.eventsRunning[eventName] = true;\n\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent(eventName+'-throttled'));\n                this.eventsRunning[eventName] = false;\n            });\n        });\n\n        if (typeof callback == 'function') {\n            window.addEventListener(eventName+'-throttled', callback);\n        }\n    }\n\n    /**\n     * Setup and throttle event listeners -- scroll & resize\n     */\n    setupEventListeners() {\n        this.throttleEventListener('resize', this.resizeHandler.bind(this));\n        this.throttleEventListener('scroll', this.scrollHandler.bind(this));\n    }\n\n    /**\n     * Print a debug message\n     */\n    debug() {\n        if (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n        }\n    }\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n    /**\n     * Get all the HTML elements configured for image selection\n     */\n    getElements() {\n        this.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (var i =0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n            this.elementCache.push({\n                el: el,\n                elType: el.tagName.toLowerCase(),\n                container: this.getContainerDimensions(el),\n                sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n                // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n                loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t\t\t}\n            });\n\t\t}\n\n        // document.querySelectorAll(`[${this.config.attributes.sources}]`).forEach((el) => {\n        //     this.elementCache.push({\n        //         el: el,\n        //         elType: el.tagName.toLowerCase(),\n        //         container: this.getContainerDimensions(el),\n        //         sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n        //         // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n        //         loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t// \t\toptions: {\n\t\t// \t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t// \t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t// \t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t// \t\t}\n        //     });\n        // });\n\n        this.debugInfo(this.elementCache);\n    }\n\n    /**\n     * Get container dimensions of an HTML element\n     *\n     * @param {object} el\n     */\n    getContainerDimensions(el) {\n        let container = {\n            width: 0,\n            height: 0\n        };\n\n\t\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\t\tif (displayStyle != 'block' && el.parentElement) {\n\t\t\tcontainer = this.getContainerDimensions(el.parentElement);\n\t\t} else {\n\t\t\tcontainer.width = el.clientWidth;\n\t\t\tcontainer.height = el.clientHeight;\n\t\t}\n\n\t\t// switch (el.tagName.toLowerCase()) {\n\t\t// \tcase 'section':\n\t\t// \tcase 'div':\n\t\t// \t\tcontainer.width = el.clientWidth;\n\t\t// \t\tcontainer.height = el.clientHeight;\n\t\t// \t\tbreak;\n\t\t//\n\t\t// \tdefault:\n\t\t// \t\tif (el.parentElement) {\n\t\t// \t\t\tcontainer = this.getContainerDimensions(el.parentElement);\n\t\t// \t\t}\n\t\t//\n\t\t// \t\tbreak;\n\t\t// }\n\n        return container;\n    }\n\n    /**\n     * Create an array of image sizes from the \"data-it-sources\" attribute\n     *\n     * @param {string} rImgSources\n     */\n    getSizes(rImgSources) {\n        return rImgSources\n            .split(';')\n            .map(sizeEl => {\n                const [url, width, height] = sizeEl.split(',');\n                return { url: url, width: parseInt(width), height: parseInt(height) };\n            })\n            .sort((a, b) => {\n                if (a.width >= a.height) {\n                    return a.width > b.width ? 1 : -1;\n                } else {\n                    return a.height > b.height ? 1 : -1;\n                }\n            });\n    }\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tconst isLandscape = containerWidth > containerHeight;\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth-imageWidth);\n\t\t}\n\n\t\tif (imageHeight >= containerHeight) {\n\t\t\tscore *= containerHeight / imageHeight;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerHeight-imageHeight);\n\t\t}\n\n\n\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n    /**\n     * Choose the appropriate image and apply it to the element\n     *\n     * @param {object} item\n     */\n    chooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n        const elType = item.el.tagName.toLowerCase();\n\n        const container = this.getContainerDimensions(item.el);\n\n\t\t// if (this.opts.matchDPR) {\n\t\tif (item.options.matchDPR) {\n            container.width *= window.devicePixelRatio;\n            container.height *= window.devicePixelRatio;\n        }\n\n\t\t// let possibleSizes = sizes.filter(function(size) {\n\t\t// \treturn size.width >= container.width && size.height >= container.height;\n        // });\n\n\t\tlet scoredSizes = sizes.map(size => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n        let idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n\t\tif (elType == 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n        item.loaded = true;\n    }\n\n    /**\n     * Resize handler\n     */\n    resizeHandler() {\n        // update container sizes\n        this.debug('resizeHandler');\n    }\n\n    /**\n     * Scroll handler -- check for lazy load-able images\n     */\n    scrollHandler() {\n        // lazy load images\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n            \tcontinue;\n            }\n\n            // this.debugInfo('choosing image', item);\n\t\t\tconsole.log('lazy loading', item);\n            this.chooseImage(item);\n\t\t}\n\n        // this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     // this.debugInfo('choosing image', item);\n\t\t// \tconsole.log('lazy loading', item);\n        //     this.chooseImage(item);\n        // });\n    }\n}\n"]}