{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","to","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","window","CustomEvent","event","params","evtParams","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","Event","ImageTools","_class","opts","_classCallCheck","this","eventsRunning","elementCache","config","events","resize","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","noHeight","debug","matchDPR","setupEventListeners","update","_createClass","key","value","getElements","i","item","loaded","options","canLazyLoad","el","offsetTop","pageYOffset","innerHeight","eventName","callback","_this","requestAnimationFrame","dispatchEvent","throttleEventListener","resizeHandler","bind","scrollHandler","_console","console","log","apply","_console2","info","chooseImage","_console3","table","foundEls","querySelectorAll","push","elType","tagName","toLowerCase","sizes","getSizes","getAttribute","addEventListener","debugInfo","displayStyle","style","display","getComputedStyle","container","width","clientWidth","height","clientHeight","getElementWidth","parentElement","parseInt","sort","a","b","containerWidth","containerHeight","imageWidth","imageHeight","score","Math","abs","_this2","devicePixelRatio","scoredSizes","map","size","calculateUsabilityScore","debugTable","idealImage","url","backgroundImage"],"mappings":"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","file":"imageTools.es5.min.js","sourcesContent":["/**\n * Object.assign polyfill for IE\n */\nif (typeof Object.assign != 'function') {\n\tObject.assign = function(target, varArgs) { // .length of function is 2\n\t\t'use strict';\n\n\t\tif (target === null) { // TypeError if undefined or null\n\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t\t}\n\n\t\tvar to = Object(target);\n\n\t\tfor (var index = 1; index < arguments.length; index++) {\n\t\t\tvar nextSource = arguments[index];\n\n\t\t\tif (nextSource !== null) { // Skip over if undefined or null\n\t\t\t\tfor (var nextKey in nextSource) {\n\t\t\t\t\t// Avoid bugs when hasOwnProperty is shadowed\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t};\n}\n\n/**\n * Event constructor polyfill for IE\n */\nif (typeof window.CustomEvent !== 'function') {\n\tconst CustomEvent = function(event, params) {\n\t\tconst evtParams = params || { bubbles: false, cancelable: false, detail: undefined };\n\t\tconst evt = document.createEvent('CustomEvent');\n\n\t\tevt.initCustomEvent(event, evtParams.bubbles, evtParams.cancelable, evtParams.detail);\n\n\t\treturn evt;\n\t};\n\n\tCustomEvent.prototype = window.Event.prototype;\n\n\twindow.CustomEvent = CustomEvent;\n}\n\n/**\n * ImageTools class\n */\nwindow.ImageTools = class {\n\t/**\n\t * Constructor\n\t *\n\t * @param {object} opts\n\t */\n\tconstructor(opts) {\n\t\tthis.eventsRunning = {};\n\t\tthis.elementCache = [];\n\n\t\tthis.config = {\n\t\t\tevents: {\n\t\t\t\tresize: 'imageToolsResize',\n\t\t\t\tscroll: 'imageToolsScroll'\n\t\t\t},\n\t\t\tattributes: {\n\t\t\t\t// enabled: 'data-it-enabled',\n\t\t\t\tsources: 'data-it-sources',\n\t\t\t\tlazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr',\n\t\t\t\tnoHeight: 'data-it-no-height'\n\t\t\t}\n\t\t};\n\n\t\tthis.opts = Object.assign({\n\t\t\tdebug: false,\n\t\t\tmatchDPR: true,\n\t\t\tlazyLoad: true,\n\t\t\tlazyLoadThreshold: 100\n\t\t}, opts);\n\n\t\t// const defaults = {\n\t\t// \tdebug: false,\n\t\t// \tmatchDPR: true,\n\t\t// \tlazyLoad: true,\n\t\t// \tlazyLoadThreshold: 100\n\t\t// };\n\n\t\t// this.opts = { ...defaults, ...opts };\n\n\t\tthis.setupEventListeners();\n\t\tthis.update();\n\t}\n\n\tupdate() {\n\t\tthis.getElements();\n\n\t\tfor (let i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && this.canLazyLoad(item) === false)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.chooseImage(item);\n\t\t}\n\t}\n\n\t/**\n\t * Test if an item is lazy load-able\n\t *\n\t * @param {object} item\n\t */\n\tcanLazyLoad(item) {\n\t\tif (!item.options.lazyLoad || item.loaded) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (item.el.offsetTop - (window.pageYOffset + window.innerHeight) <= item.options.lazyLoadThreshold) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Setup a throttled event listener\n\t *\n\t * @param {string} name\n\t * @param {function} callback\n\t */\n\tthrottleEventListener(eventName, callback) {\n\t\tif (!this.eventsRunning.hasOwnProperty(eventName)) {\n\t\t\tthis.eventsRunning[eventName] = false;\n\t\t}\n\n\t\twindow.addEventListener(eventName, () => {\n\t\t\tif (this.eventsRunning[eventName]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.eventsRunning[eventName] = true;\n\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\twindow.dispatchEvent(new CustomEvent(`${eventName}-throttled`));\n\t\t\t\tthis.eventsRunning[eventName] = false;\n\t\t\t});\n\t\t});\n\n\t\tif (typeof callback === 'function') {\n\t\t\twindow.addEventListener(`${eventName}-throttled`, callback);\n\t\t}\n\t}\n\n\t/**\n\t * Setup and throttle event listeners -- scroll & resize\n\t */\n\tsetupEventListeners() {\n\t\tthis.throttleEventListener('resize', this.resizeHandler.bind(this));\n\t\tthis.throttleEventListener('scroll', this.scrollHandler.bind(this));\n\t}\n\n\t/**\n\t * Print a debug message\n\t */\n\tdebug() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n\t\t}\n\t}\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n\t/**\n\t * Get all the HTML elements configured for image selection\n\t */\n\tgetElements() {\n\t\tthis.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (let i = 0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n\t\t\tthis.elementCache.push({\n\t\t\t\tel: el,\n\t\t\t\telType: el.tagName.toLowerCase(),\n\t\t\t\t// container: this.getContainerDimensions(el),\n\t\t\t\tsizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n\t\t\t\tloaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad).toLowerCase() === 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t\t\t\tnoHeight: el.getAttribute(this.config.attributes.noHeight) ? el.getAttribute(this.config.attributes.noHeight) : false\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.debugInfo(this.elementCache);\n\t}\n\n\t/**\n\t * Get container dimensions of an HTML element\n\t *\n\t * @param {object} el\n\t * @param {bool} noHeight\n\t */\n\tgetContainerDimensions(el, noHeight) {\n\t\t// FIXME:\n\t\t// this is tricky since an IMG tag may not have a set height and we can't rely on\n\t\t// its container for that height value\n\t\t// I'm thinking the best way to tackle this is to see if the element has a height\n\t\t// specified -- if not we'll disregard the height value\n\t\t//      - how does a 100% height work with this?\n\n\t\t// el.clientHeight works fine on all tags except IMG\n\n\t\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\t\tconst container = {\n\t\t\twidth: (displayStyle == 'block') ? el.clientWidth : 0,\n\t\t\theight: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n\t\t};\n\n\t\tif (!container.width) {\n\t\t\tcontainer.width = this.getElementWidth(el.parentElement);\n\t\t}\n\n\t\tif (noHeight) {\n\t\t\tcontainer.height = 0;\n\t\t}\n\n\t\treturn container;\n\t}\n\n\t/**\n\t * Return the width of a tested element\n\t * This will examine a style attribute tag first and fallback to the computed style\n\t * \n\t * @param {object} el \n\t */\n\tgetElementWidth(el) {\n\t\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\t\tif (displayStyle != 'block' && el.parentElement) {\n\t\t\treturn this.getElementWidth(el.parentElement);\n\t\t}\n\n\t\treturn el.clientWidth;\n\t}\n\n\t/**\n\t * Create an array of image sizes from the \"data-it-sources\" attribute\n\t *\n\t * @param {string} rImgSources\n\t */\n\tgetSizes(rImgSources) {\n\t\treturn rImgSources\n\t\t\t.split(';')\n\t\t\t.map(sizeEl => {\n\t\t\t\tconst [url, width, height] = sizeEl.split(',');\n\t\t\t\treturn { url: url, width: parseInt(width), height: parseInt(height) };\n\t\t\t})\n\t\t\t.sort((a, b) => {\n\t\t\t\tif (a.width >= a.height) {\n\t\t\t\t\treturn a.width > b.width ? 1 : -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn a.height > b.height ? 1 : -1;\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tthis.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth - imageWidth);\n\t\t}\n\n\t\tif (containerHeight) {\n\t\t\tif (imageHeight >= containerHeight) {\n\t\t\t\tscore *= containerHeight / imageHeight;\n\t\t\t} else {\n\t\t\t\tscore -= Math.abs(containerHeight - imageHeight);\n\t\t\t}\n\t\t}\n\n\t\t// const isLandscape = containerWidth > containerHeight;\n\t\t\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n\t/**\n\t * Choose the appropriate image and apply it to the element\n\t *\n\t * @param {object} item\n\t */\n\tchooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n\t\tconst elType = item.el.tagName.toLowerCase();\n\n\t\tconst container = this.getContainerDimensions(item.el, item.options.noHeight);\n\n\t\tif (item.options.matchDPR) {\n\t\t\tcontainer.width *= window.devicePixelRatio;\n\t\t\tcontainer.height *= window.devicePixelRatio;\n\t\t}\n\n\t\tconst scoredSizes = sizes.map((size) => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n\t\tconst idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n\t\tif (elType === 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n\t\titem.loaded = true;\n\t}\n\n\t/**\n\t * Resize handler\n\t */\n\tresizeHandler() {\n\t\t// update container sizes\n\t\tthis.debug('resizeHandler');\n\t}\n\n\t/**\n\t * Scroll handler -- check for lazy load-able images\n\t */\n\tscrollHandler() {\n\t\t// lazy load images\n\t\tfor (let i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.debugInfo('choosing image', item);\n\n\t\t\tthis.chooseImage(item);\n\t\t}\n\t}\n}\n"]}