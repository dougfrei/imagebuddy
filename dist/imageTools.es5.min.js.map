{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","to","ImageTools","opts","_classCallCheck","this","eventsRunning","elementCache","config","resize","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","matchDPR","events","getElements","i","item","loaded","options","canLazyLoad","chooseImage","el","offsetTop","window","scrollY","innerHeight","eventName","addEventListener","_this","requestAnimationFrame","dispatchEvent","CustomEvent","callback","throttleEventListener","resizeHandler","bind","scrollHandler","debug","_console3","console","table","apply","foundEls","document","querySelectorAll","push","elType","tagName","toLowerCase","container","getContainerDimensions","sizes","getSizes","log","getAttribute","debugInfo","width","displayStyle","clientWidth","height","clientHeight","getElementWidth","parentElement","getComputedStyle","parseInt","style","display","rImgSources","split","map","sizeEl","_sizeEl$split","_sizeEl$split2","_slicedToArray","url","sort","a","b","containerWidth","containerHeight","imageWidth","imageHeight","score","Math","abs","_this2","isLandscape","devicePixelRatio","scoredSizes","size","debugTable","idealImage","setAttribute","backgroundImage"],"mappings":"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","file":"imageTools.es5.min.js","sourcesContent":["// Object.assign polyfill for IE\n\nif (typeof Object.assign != 'function') {\n    Object.assign = function(target, varArgs) { // .length of function is 2\n        'use strict';\n        \n        if (target === null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var to = Object(target);\n\n        for (var index = 1; index < arguments.length; index++) {\n            var nextSource = arguments[index];\n\n            if (nextSource !== null) { // Skip over if undefined or null\n                for (var nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n\n        return to;\n    };\n}\n\nclass ImageTools {\n    /**\n     * Constructor\n     *\n     * @param {object} opts\n     */\n    constructor(opts) {\n        this.eventsRunning = {};\n        this.elementCache = [];\n\n        this.config = {\n            events: {\n                resize: 'imageToolsResize',\n                scroll: 'imageToolsScroll'\n            },\n            attributes: {\n                // enabled: 'data-it-enabled',\n                sources: 'data-it-sources',\n                lazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr'\n            }\n        };\n\n        this.opts = Object.assign({\n            debug: false,\n            matchDPR: true,\n            lazyLoad: false,\n            lazyLoadThreshold: 100\n        }, opts);\n\n        this.setupEventListeners();\n\t\tthis.update();\n    }\n\n\tupdate() {\n\t\tthis.getElements();\n\n\t\t// this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     this.chooseImage(item);\n        // });\n\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t    if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n                continue;\n            }\n\n            this.chooseImage(item);\n\t\t}\n\t}\n\n    /**\n     * Loop through the current element cache and choose images\n     */\n    // processElementCache() {\n    //     this.elementCache.forEach(item => {\n    //         if (item.loaded || (item.lazyLoad && !this.canLazyLoad(item))) {\n    //             return;\n    //         }\n\t//\n    //         this.chooseImage(item);\n    //     });\n    // }\n\n    /**\n     * Test if an item is lazy load-able\n     *\n     * @param {object} item\n     */\n    canLazyLoad(item) {\n        if (!item.options.lazyLoad || item.loaded) {\n            return false;\n        }\n\n        // if (item.el.offsetTop - (window.scrollY + window.innerHeight) <= this.opts.lazyLoadThreshold) {\n\t\tif (item.el.offsetTop - (window.scrollY + window.innerHeight) <= item.options.lazyLoadThreshold) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Setup a throttled event listener\n     *\n     * @param {string} name\n     * @param {function} callback\n     */\n    throttleEventListener(eventName, callback) {\n        if (!this.eventsRunning.hasOwnProperty(eventName)) {\n            this.eventsRunning[eventName] = false;\n        }\n\n        window.addEventListener(eventName, () => {\n            if (this.eventsRunning[eventName]) {\n                return;\n            }\n\n            this.eventsRunning[eventName] = true;\n\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent(eventName+'-throttled'));\n                this.eventsRunning[eventName] = false;\n            });\n        });\n\n        if (typeof callback == 'function') {\n            window.addEventListener(eventName+'-throttled', callback);\n        }\n    }\n\n    /**\n     * Setup and throttle event listeners -- scroll & resize\n     */\n    setupEventListeners() {\n        this.throttleEventListener('resize', this.resizeHandler.bind(this));\n        this.throttleEventListener('scroll', this.scrollHandler.bind(this));\n    }\n\n    /**\n     * Print a debug message\n     */\n    debug() {\n        if (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n        }\n    }\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n    /**\n     * Get all the HTML elements configured for image selection\n     */\n    getElements() {\n        this.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (var i =0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n            this.elementCache.push({\n                el: el,\n                elType: el.tagName.toLowerCase(),\n                container: this.getContainerDimensions(el),\n                sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n                // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n                loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t\t\t}\n            });\n\t\t}\n\n        // document.querySelectorAll(`[${this.config.attributes.sources}]`).forEach((el) => {\n        //     this.elementCache.push({\n        //         el: el,\n        //         elType: el.tagName.toLowerCase(),\n        //         container: this.getContainerDimensions(el),\n        //         sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n        //         // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n        //         loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t// \t\toptions: {\n\t\t// \t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t// \t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t// \t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t// \t\t}\n        //     });\n        // });\n\n        this.debugInfo(this.elementCache);\n    }\n\n    /**\n     * Get container dimensions of an HTML element\n     *\n     * @param {object} el\n     */\n    getContainerDimensions(el) {\n        // FIXME:\n        // this is tricky since an IMG tag may not have a set height and we can't rely on\n        // its container for that height value\n        // I'm thinking the best way to tackle this is to see if the element has a height\n        // specified -- if not we'll disregard the height value\n        //      - how does a 100% height work with this?\n\n        // el.clientHeight works fine on all tags except IMG\n\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        let container = {\n            width: (displayStyle == 'block') ? el.clientWidth : 0,\n            height: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n        };\n\n        if (!container.width) {\n            container.width = this.getElementWidth(el.parentElement);\n        }\n\n        console.log('height', window.getComputedStyle(el).height, parseInt(window.getComputedStyle(el).height));\n        console.log(displayStyle, container, el.clientHeight);\n\n        return container;\n\n\t\t\n        // console.log(`displayStyle: ${displayStyle}`);\n        \n\n\t\t// if (displayStyle != 'block' && el.parentElement) {\n\t\t// \tcontainer = this.getContainerDimensions(el.parentElement);\n\t\t// } else {\n\t\t// \tcontainer.width = el.clientWidth;\n\t\t// \tcontainer.height = el.clientHeight;\n\t\t// }\n\n\t\t// // switch (el.tagName.toLowerCase()) {\n\t\t// // \tcase 'section':\n\t\t// // \tcase 'div':\n\t\t// // \t\tcontainer.width = el.clientWidth;\n\t\t// // \t\tcontainer.height = el.clientHeight;\n\t\t// // \t\tbreak;\n\t\t// //\n\t\t// // \tdefault:\n\t\t// // \t\tif (el.parentElement) {\n\t\t// // \t\t\tcontainer = this.getContainerDimensions(el.parentElement);\n\t\t// // \t\t}\n\t\t// //\n\t\t// // \t\tbreak;\n\t\t// // }\n\n        // return container;\n    }\n\n    getElementWidth(el) {\n        console.log('getting parent element width', el.tagName.toLowerCase());\n\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        if (displayStyle != 'block' && el.parentElement) {\n            return this.getElementWidth(el.parentElement);\n        }\n\n        return el.clientWidth;\n    }\n\n    /**\n     * Create an array of image sizes from the \"data-it-sources\" attribute\n     *\n     * @param {string} rImgSources\n     */\n    getSizes(rImgSources) {\n        return rImgSources\n            .split(';')\n            .map(sizeEl => {\n                const [url, width, height] = sizeEl.split(',');\n                return { url: url, width: parseInt(width), height: parseInt(height) };\n            })\n            .sort((a, b) => {\n                if (a.width >= a.height) {\n                    return a.width > b.width ? 1 : -1;\n                } else {\n                    return a.height > b.height ? 1 : -1;\n                }\n            });\n    }\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tconst isLandscape = containerWidth > containerHeight;\n\n        this.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth-imageWidth);\n\t\t}\n\n        if (containerHeight) {\n            if (imageHeight >= containerHeight) {\n                score *= containerHeight / imageHeight;\n            } else {\n                score -= Math.abs(containerHeight-imageHeight);\n            }\n        }\n\n\n\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n    /**\n     * Choose the appropriate image and apply it to the element\n     *\n     * @param {object} item\n     */\n    chooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n        const elType = item.el.tagName.toLowerCase();\n\n        const container = this.getContainerDimensions(item.el);\n\n\t\t// if (this.opts.matchDPR) {\n\t\tif (item.options.matchDPR) {\n            container.width *= window.devicePixelRatio;\n            container.height *= window.devicePixelRatio;\n        }\n\n\t\t// let possibleSizes = sizes.filter(function(size) {\n\t\t// \treturn size.width >= container.width && size.height >= container.height;\n        // });\n\n\t\tlet scoredSizes = sizes.map(size => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n        let idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n\t\tif (elType == 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n        item.loaded = true;\n    }\n\n    /**\n     * Resize handler\n     */\n    resizeHandler() {\n        // update container sizes\n        this.debug('resizeHandler');\n    }\n\n    /**\n     * Scroll handler -- check for lazy load-able images\n     */\n    scrollHandler() {\n        // lazy load images\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n            \tcontinue;\n            }\n\n            // this.debugInfo('choosing image', item);\n\t\t\tconsole.log('lazy loading', item);\n            this.chooseImage(item);\n\t\t}\n\n        // this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     // this.debugInfo('choosing image', item);\n\t\t// \tconsole.log('lazy loading', item);\n        //     this.chooseImage(item);\n        // });\n    }\n}\n"]}