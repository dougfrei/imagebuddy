{"version":3,"sources":["imageTools.js"],"names":["Object","assign","target","varArgs","TypeError","index","arguments","length","nextSource","nextKey","prototype","hasOwnProperty","call","to","CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","window","Event","ImageTools","opts","_classCallCheck","this","elementCache","events","resize","scroll","attributes","sources","lazyLoad","lazyLoadThreshold","eventsRunning","matchDPR","i","item","loaded","options","canLazyLoad","chooseImage","el","offsetTop","pageYOffset","innerHeight","eventName","callback","_this","addEventListener","requestAnimationFrame","dispatchEvent","resizeHandler","bind","throttleEventListener","scrollHandler","_console","console","log","apply","_console2","info","debug","_console3","table","foundEls","querySelectorAll","config","elType","tagName","toLowerCase","container","getContainerDimensions","sizes","getSizes","getAttribute","debugInfo","displayStyle","style","display","getComputedStyle","width","height","clientHeight","parentElement","getElementWidth","rImgSources","split","map","sizeEl","_sizeEl$split","_sizeEl$split2","_slicedToArray","url","parseInt","sort","a","b","containerHeight","clientWidth","imageHeight","containerWidth","imageWidth","score","Math","abs","_this2","isLandscape","devicePixelRatio","scoredSizes","size","debugTable","idealImage","setAttribute","backgroundImage"],"mappings":"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","file":"imageTools.es5.min.js","sourcesContent":["// Object.assign polyfill for IE\nif (typeof Object.assign != 'function') {\n    Object.assign = function(target, varArgs) { // .length of function is 2\n        'use strict';\n        \n        if (target === null) { // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var to = Object(target);\n\n        for (var index = 1; index < arguments.length; index++) {\n            var nextSource = arguments[index];\n\n            if (nextSource !== null) { // Skip over if undefined or null\n                for (var nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n\n        return to;\n    };\n}\n\n// Event constructor polyfill for IE\n(function () {\n    if (typeof window.CustomEvent === 'function')\n        return false;\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        \n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n})();\n\nclass ImageTools {\n    /**\n     * Constructor\n     *\n     * @param {object} opts\n     */\n    constructor(opts) {\n        this.eventsRunning = {};\n        this.elementCache = [];\n\n        this.config = {\n            events: {\n                resize: 'imageToolsResize',\n                scroll: 'imageToolsScroll'\n            },\n            attributes: {\n                // enabled: 'data-it-enabled',\n                sources: 'data-it-sources',\n                lazyLoad: 'data-it-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-it-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-it-match-dpr'\n            }\n        };\n\n        this.opts = Object.assign({\n            debug: false,\n            matchDPR: true,\n            lazyLoad: true,\n            lazyLoadThreshold: 100\n        }, opts);\n\n        this.setupEventListeners();\n\t\tthis.update();\n    }\n\n\tupdate() {\n        this.getElements();\n\n\t\t// this.elementCache.forEach(item => {\n        //     if (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n        //         return;\n        //     }\n\t\t//\n        //     this.chooseImage(item);\n        // });\n\n        for (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n            if (item.loaded || (item.options.lazyLoad && this.canLazyLoad(item) === false)) {\n                continue;\n            }\n\n            this.chooseImage(item);\n\t\t}\n\t}\n\n    /**\n     * Test if an item is lazy load-able\n     *\n     * @param {object} item\n     */\n    canLazyLoad(item) {\n        if (!item.options.lazyLoad || item.loaded) {\n            return false;\n        }\n\n        // if (item.el.offsetTop - (window.scrollY + window.innerHeight) <= item.options.lazyLoadThreshold) {\n        if (item.el.offsetTop - (window.pageYOffset + window.innerHeight) <= item.options.lazyLoadThreshold) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Setup a throttled event listener\n     *\n     * @param {string} name\n     * @param {function} callback\n     */\n    throttleEventListener(eventName, callback) {\n        if (!this.eventsRunning.hasOwnProperty(eventName)) {\n            this.eventsRunning[eventName] = false;\n        }\n\n        window.addEventListener(eventName, () => {\n            if (this.eventsRunning[eventName]) {\n                return;\n            }\n\n            this.eventsRunning[eventName] = true;\n\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent(eventName+'-throttled'));\n                this.eventsRunning[eventName] = false;\n            });\n        });\n\n        if (typeof callback == 'function') {\n            window.addEventListener(eventName+'-throttled', callback);\n        }\n    }\n\n    /**\n     * Setup and throttle event listeners -- scroll & resize\n     */\n    setupEventListeners() {\n        this.throttleEventListener('resize', this.resizeHandler.bind(this));\n        this.throttleEventListener('scroll', this.scrollHandler.bind(this));\n    }\n\n    /**\n     * Print a debug message\n     */\n    debug() {\n        if (this.opts.debug) {\n\t\t\tconsole.log(...arguments);\n        }\n    }\n\n\tdebugInfo() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.info(...arguments);\n\t\t}\n\t}\n\n\tdebugTable() {\n\t\tif (this.opts.debug) {\n\t\t\tconsole.table(...arguments);\n\t\t}\n\t}\n\n    /**\n     * Get all the HTML elements configured for image selection\n     */\n    getElements() {\n        this.elementCache = [];\n\n\t\tconst foundEls = document.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (var i =0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\n            this.elementCache.push({\n                el: el,\n                elType: el.tagName.toLowerCase(),\n                container: this.getContainerDimensions(el),\n                sizes: this.getSizes(el.getAttribute(this.config.attributes.sources)),\n                // lazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n                loaded: false, // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\t\t\toptions: {\n\t\t\t\t\tlazyLoad: el.getAttribute(this.config.attributes.lazyLoad) ? el.getAttribute(this.config.attributes.lazyLoad) == 'true' : this.opts.lazyLoad,\n\t\t\t\t\tlazyLoadThreshold: el.getAttribute(this.config.attributes.lazyLoadThreshold) ? el.getAttribute(this.config.attributes.lazyLoadThreshold) : this.opts.lazyLoadThreshold,\n\t\t\t\t\tmatchDPR: el.getAttribute(this.config.attributes.matchDPR) ? el.getAttribute(this.config.attributes.matchDPR) : this.opts.matchDPR,\n\t\t\t\t}\n            });\n\t\t}\n\n        this.debugInfo(this.elementCache);\n    }\n\n    /**\n     * Get container dimensions of an HTML element\n     *\n     * @param {object} el\n     */\n    getContainerDimensions(el) {\n        // FIXME:\n        // this is tricky since an IMG tag may not have a set height and we can't rely on\n        // its container for that height value\n        // I'm thinking the best way to tackle this is to see if the element has a height\n        // specified -- if not we'll disregard the height value\n        //      - how does a 100% height work with this?\n\n        // el.clientHeight works fine on all tags except IMG\n\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        let container = {\n            width: (displayStyle == 'block') ? el.clientWidth : 0,\n            height: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n        };\n\n        if (!container.width) {\n            container.width = this.getElementWidth(el.parentElement);\n        }\n\n        return container;\n    }\n\n    getElementWidth(el) {\n        const displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n        if (displayStyle != 'block' && el.parentElement) {\n            return this.getElementWidth(el.parentElement);\n        }\n\n        return el.clientWidth;\n    }\n\n    /**\n     * Create an array of image sizes from the \"data-it-sources\" attribute\n     *\n     * @param {string} rImgSources\n     */\n    getSizes(rImgSources) {\n        return rImgSources\n            .split(';')\n            .map(sizeEl => {\n                const [url, width, height] = sizeEl.split(',');\n                return { url: url, width: parseInt(width), height: parseInt(height) };\n            })\n            .sort((a, b) => {\n                if (a.width >= a.height) {\n                    return a.width > b.width ? 1 : -1;\n                } else {\n                    return a.height > b.height ? 1 : -1;\n                }\n            });\n    }\n\n\tcalculateUsabilityScore(containerWidth, containerHeight, imageWidth, imageHeight) {\n\t\tconst isLandscape = containerWidth > containerHeight;\n\n        this.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\t\tlet score = 1;\n\n\t\tif (imageWidth >= containerWidth) {\n\t\t\tscore *= containerWidth / imageWidth;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerWidth-imageWidth);\n\t\t}\n\n        if (containerHeight) {\n            if (imageHeight >= containerHeight) {\n                score *= containerHeight / imageHeight;\n            } else {\n                score -= Math.abs(containerHeight-imageHeight);\n            }\n        }\n\n\n\n\t\t// let containerRatio = isLandscape ? containerWidth / containerHeight : containerHeight / containerWidth;\n\t\t// let imageRatio = isLandscape ? imageWidth / imageHeight : imageHeight / imageWidth;\n\t\t//\n\t\t// let ratioTest = Math.abs(containerRatio - imageRatio);\n\t\t// let widthTest = isLandscape ? Math.abs(imageWidth - containerWidth) : Math.abs(imageHeight - containerHeight);\n\t\t// let widthTest = isLandscape ? imageWidth - containerWidth : imageHeight - containerHeight;\n\t\t// size.score = widthTest * ratioTest;\n\n\t\t// size.containerRatio = containerRatio;\n\t\t// size.imageRatio = imageRatio;\n\t\t// size.ratioTest = ratioTest*10;\n\t\t// size.widthTest = widthTest/10;\n\n\t\t// size.score = 100 - size.widthTest - size.ratioTest;\n\n\t\treturn score;\n\t}\n\n    /**\n     * Choose the appropriate image and apply it to the element\n     *\n     * @param {object} item\n     */\n    chooseImage(item) {\n\t\tconst sizes = this.getSizes(item.el.getAttribute(this.config.attributes.sources));\n        const elType = item.el.tagName.toLowerCase();\n\n        const container = this.getContainerDimensions(item.el);\n\n\t\t// if (this.opts.matchDPR) {\n\t\tif (item.options.matchDPR) {\n            container.width *= window.devicePixelRatio;\n            container.height *= window.devicePixelRatio;\n        }\n\n\t\t// let possibleSizes = sizes.filter(function(size) {\n\t\t// \treturn size.width >= container.width && size.height >= container.height;\n        // });\n\n\t\tlet scoredSizes = sizes.map(size => {\n\t\t\tsize.score = this.calculateUsabilityScore(container.width, container.height, size.width, size.height);\n\n\t\t\treturn size;\n\t\t});\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\tthis.debugTable(scoredSizes);\n\n        let idealImage = scoredSizes[scoredSizes.length-1];\n\n\t\tthis.debug(idealImage);\n\n        if (elType == 'img') {\n\t\t\titem.el.setAttribute('src', idealImage.url);\n\t\t} else {\n\t\t\titem.el.style.backgroundImage = `url('${idealImage.url}')`;\n\t\t}\n\n        item.loaded = true;\n    }\n\n    /**\n     * Resize handler\n     */\n    resizeHandler() {\n        // update container sizes\n        this.debug('resizeHandler');\n    }\n\n    /**\n     * Scroll handler -- check for lazy load-able images\n     */\n    scrollHandler() {\n        // lazy load images\n\t\tfor (var i = 0; i < this.elementCache.length; i++) {\n\t\t\tconst item = this.elementCache[i];\n\n\t\t\tif (item.loaded || (item.options.lazyLoad && !this.canLazyLoad(item))) {\n            \tcontinue;\n            }\n\n            this.debugInfo('choosing image', item);\n\t\t\t\n            this.chooseImage(item);\n        }\n    }\n}\n"]}