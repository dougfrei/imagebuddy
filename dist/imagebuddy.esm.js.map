{"version":3,"file":"imagebuddy.esm.js","sources":["../source/ImageBuddyDebug.ts","../source/ImageBuddyEvents.ts","../source/ImageBuddyUtil.ts","../source/DOMUtil.ts","../source/ImageBuddyDOMElement.ts","../source/ImageBuddy.ts"],"sourcesContent":["export default class {\n\tenabled: boolean;\n\n\tconstructor(enabled = false) {\n\t\tthis.enabled = enabled;\n\t}\n\n\tdebug(...args: any[]) {\n\t\tif (this.enabled) {\n\t\t\tconsole.log(...args);\n\t\t}\n\t}\n\n\tdebugInfo(...args: any[]) {\n\t\tif (this.enabled) {\n\t\t\tconsole.info(...args);\n\t\t}\n\t}\n\n\tdebugTable(...args: any[]) {\n\t\tif (this.enabled) {\n\t\t\tconsole.table(...args);\n\t\t}\n\t}\n}\n","const events: any = {};\n\nexport default class {\n\tstatic on(event: string, listener: CallableFunction) {\n\t\tif (typeof events[event] !== 'object') {\n\t\t\tevents[event] = [];\n\t\t}\n\n\t\tevents[event].push(listener);\n\t}\n\n\tstatic emit(event: string, ...args: any[]) {\n\t\tconst eventArgs = args;\n\n\t\t// allow handlers to register themselves before executing\n\t\tsetTimeout(() => {\n\t\t\tif (typeof events[event] === 'object') {\n\t\t\t\tconst listeners = events[event].slice();\n\n\t\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\t\tlisteners[i].apply(null, eventArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t}, 0);\n\t}\n}\n","export function stringToBoolean(attrVal: string): boolean {\n\tconst refVal = attrVal.trim().toLowerCase();\n\n\tif (refVal === 'true') {\n\t\treturn true;\n\t}\n\n\tif (refVal === 'false') {\n\t\treturn false;\n\t}\n\n\tconst numVal = parseInt(refVal, 10);\n\n\treturn numVal > 0;\n}\n","import { ImageSource, ImageSize } from './interfaces/index';\n\nexport function getPageYOffset(): number {\n\tif (typeof window.pageYOffset !== 'undefined') {\n\t\treturn window.pageYOffset;\n\t}\n\n\tconst scrollEl = document.scrollingElement || document.documentElement;\n\n\treturn scrollEl.scrollTop;\n}\n\nexport function calculateElementTopOffset(el: HTMLElement): number {\n\treturn el.getBoundingClientRect().top + getPageYOffset();\n}\n\n/**\n * Create an array of image sizes from the \"data-ib-sources\" attribute\n *\n * @param {string} rImgSources\n */\nexport function getSizesFromAttribute(rImgSources: string): ImageSource[] {\n\tif (!rImgSources.trim()) {\n\t\treturn [];\n\t}\n\n\treturn rImgSources\n\t\t.split(',')\n\t\t.map((sizeEl) => {\n\t\t\tconst [url, width, height] = sizeEl.trim().split(' ');\n\n\t\t\treturn {\n\t\t\t\turl,\n\t\t\t\twidth: parseInt(width, 10),\n\t\t\t\theight: parseInt(height, 10)\n\t\t\t};\n\t\t})\n\t\t.sort((a, b) => {\n\t\t\tif (a.width >= a.height) {\n\t\t\t\treturn a.width > b.width ? 1 : -1;\n\t\t\t}\n\n\t\t\treturn a.height > b.height ? 1 : -1;\n\t\t});\n}\n\nexport function elementIsCached(el: Element): boolean {\n\tif (!el) {\n\t\treturn false;\n\t}\n\n\tif (el.hasAttribute('data-ib-no-cache')) {\n\t\treturn false;\n\t}\n\n\tif (el.getAttribute('data-ib-cache-id')) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function shouldIgnoreElement(el: Element) {\n\treturn el.hasAttribute('data-ib-ignore');\n}\n\nexport function calculateUsabilityScore(containerWidth: number, containerHeight: number, imageWidth: number, imageHeight: number): number {\n\t// ImageBuddyUtil.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\tlet score = 1;\n\n\tif (imageWidth >= containerWidth) {\n\t\tscore *= containerWidth / imageWidth;\n\t} else {\n\t\tscore -= Math.abs(containerWidth - imageWidth);\n\t}\n\n\tif (containerHeight) {\n\t\tif (imageHeight >= containerHeight) {\n\t\t\tscore *= containerHeight / imageHeight;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerHeight - imageHeight);\n\t\t}\n\t}\n\n\treturn score;\n}\n\n/**\n * Return the width of a tested element\n * This will examine a style attribute tag first and fallback to the computed style\n *\n * @param {object} el\n */\nexport function getElementWidth(el: HTMLElement): number {\n\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\tif (displayStyle !== 'block' && el.parentElement) {\n\t\treturn getElementWidth(el.parentElement);\n\t}\n\n\treturn el.clientWidth;\n}\n\n/**\n * Get container dimensions of an HTML element\n *\n * @param {object} el\n * @param {bool} noHeight\n */\nexport function getContainerDimensions(el: HTMLElement, noHeight = false): ImageSize {\n\t// FIXME:\n\t// this is tricky since an IMG tag may not have a set height and we can't rely on\n\t// its container for that height value\n\t// I'm thinking the best way to tackle this is to see if the element has a height\n\t// specified -- if not we'll disregard the height value\n\t//      - how does a 100% height work with this?\n\n\t// el.clientHeight works fine on all tags except IMG\n\n\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\tconst container = {\n\t\twidth: (displayStyle === 'block') ? el.clientWidth : 0,\n\t\theight: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n\t};\n\n\tif (!container.width && el.parentElement) {\n\t\tcontainer.width = getElementWidth(el.parentElement);\n\t}\n\n\tif (noHeight) {\n\t\tcontainer.height = 0;\n\t}\n\n\treturn container;\n}\n\n/**\n * Creates a dummy image element and loads the requested image URL\n * Returns a promise with the loaded image URL\n *\n * @param imageURL the image URL to load\n */\nexport function loadImage(imageURL: string): Promise<string> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst imageLoader = new Image();\n\n\t\timageLoader.onload = () => {\n\t\t\tresolve(imageLoader.src);\n\t\t};\n\n\t\timageLoader.onerror = () => {\n\t\t\treject(imageLoader.src);\n\t\t}\n\n\t\timageLoader.src = imageURL;\n\t});\n}\n\nexport function compareURLs(url1: string, url2: string): boolean {\n\tconst testUrls = [url1, url2].map(url => {\n\t\tconst anchor = document.createElement('a');\n\n\t\tanchor.href = url.toLowerCase();\n\n\t\treturn anchor.host + anchor.pathname;\n\t});\n\n\treturn testUrls[0] === testUrls[1];\n}\n","import ImageBuddyEvents from './ImageBuddyEvents';\nimport { stringToBoolean } from './ImageBuddyUtil';\nimport {\n\tcalculateElementTopOffset,\n\tgetSizesFromAttribute,\n\tcalculateUsabilityScore,\n\tgetElementWidth,\n\tgetContainerDimensions,\n\tloadImage,\n\tgetPageYOffset,\n\tcompareURLs,\n} from './DOMUtil';\nimport {\n\tImageSource,\n\tImageSize,\n\tImageBuddyDOMElementOptions,\n\tImageBuddyConfig,\n\tImageBuddyOpts,\n} from './interfaces/index';\n\nexport default class {\n\tel: HTMLElement;\n\tconfig: ImageBuddyConfig;\n\telType: string;\n\tsizes: ImageSource[];\n\tcurrentSize: ImageSize;\n\tloaded: boolean;\n\tisLoading: boolean;\n\toptions: ImageBuddyDOMElementOptions;\n\toffsetTop: number;\n\n\tconstructor(\n\t\tel: HTMLElement,\n\t\tibConfig: ImageBuddyConfig,\n\t\tibOpts: ImageBuddyOpts\n\t) {\n\t\tel.classList.add(ibConfig.classes.base);\n\t\tel.setAttribute(\n\t\t\t'data-ib-cache-id',\n\t\t\tMath.random().toString(36).substring(7)\n\t\t);\n\n\t\tthis.el = el;\n\t\tthis.config = ibConfig;\n\n\t\tthis.elType = el.tagName.toLowerCase();\n\t\tthis.sizes = getSizesFromAttribute(\n\t\t\tel.getAttribute(ibConfig.attributes.sources) || ''\n\t\t);\n\t\tthis.currentSize = { width: 0, height: 0 };\n\t\tthis.loaded = false; // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\tthis.isLoading = false;\n\t\tthis.options = {\n\t\t\tlazyLoad: el.hasAttribute(ibConfig.attributes.lazyLoad)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(ibConfig.attributes.lazyLoad) || ''\n\t\t\t\t  )\n\t\t\t\t: ibOpts.lazyLoad,\n\t\t\tlazyLoadThreshold: el.hasAttribute(\n\t\t\t\tibConfig.attributes.lazyLoadThreshold\n\t\t\t)\n\t\t\t\t? parseInt(\n\t\t\t\t\t\tel.getAttribute(\n\t\t\t\t\t\t\tibConfig.attributes.lazyLoadThreshold\n\t\t\t\t\t\t) || '0',\n\t\t\t\t\t\t10\n\t\t\t\t  )\n\t\t\t\t: ibOpts.lazyLoadThreshold,\n\t\t\tmatchDPR: el.hasAttribute(ibConfig.attributes.matchDPR)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(ibConfig.attributes.matchDPR) || ''\n\t\t\t\t  )\n\t\t\t\t: ibOpts.matchDPR,\n\t\t\tnoHeight: el.hasAttribute(ibConfig.attributes.noHeight)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(ibConfig.attributes.noHeight) || ''\n\t\t\t\t  )\n\t\t\t\t: false,\n\t\t\tignoreHiddenCheck: el.hasAttribute(\n\t\t\t\tibConfig.attributes.ignoreHiddenCheck\n\t\t\t)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(\n\t\t\t\t\t\t\tibConfig.attributes.ignoreHiddenCheck\n\t\t\t\t\t\t) || ''\n\t\t\t\t  )\n\t\t\t\t: false,\n\t\t};\n\t\tthis.offsetTop = calculateElementTopOffset(this.el);\n\t}\n\n\tupdateTopOffset() {\n\t\tthis.offsetTop = calculateElementTopOffset(this.el);\n\t}\n\n\t/**\n\t * Test if an item is lazy load-able\n\t *\n\t * @param {object} item\n\t */\n\tcanLazyLoad(): boolean {\n\t\tif (!this.options.lazyLoad || this.loaded) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.offsetTop - (getPageYOffset() + window.innerHeight) <=\n\t\t\tthis.options.lazyLoadThreshold\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Choose the appropriate image and apply it to the element\n\t *\n\t * @param {object} item\n\t */\n\tasync chooseImage() {\n\t\tif (this.isLoading) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.options.ignoreHiddenCheck && this.isHidden()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.isLoading = true;\n\n\t\tconst sizes = getSizesFromAttribute(\n\t\t\tthis.el.getAttribute(this.config.attributes.sources) || ''\n\t\t);\n\t\tconst elType = this.el.tagName.toLowerCase();\n\n\t\tif (\n\t\t\telType === 'img' &&\n\t\t\tparseInt(getComputedStyle(this.el).width || '0', 10) <= 1\n\t\t) {\n\t\t\tthis.el.style.width = '100%';\n\t\t}\n\n\t\tconst container = getContainerDimensions(\n\t\t\tthis.el,\n\t\t\tthis.options.noHeight\n\t\t);\n\n\t\tif (this.options.matchDPR) {\n\t\t\tcontainer.width *= window.devicePixelRatio;\n\t\t\tcontainer.height *= window.devicePixelRatio;\n\t\t}\n\n\t\tconst scoredSizes = sizes.map((size) =>\n\t\t\tObject.assign(size, {\n\t\t\t\tscore: calculateUsabilityScore(\n\t\t\t\t\tcontainer.width,\n\t\t\t\t\tcontainer.height,\n\t\t\t\t\tsize.width,\n\t\t\t\t\tsize.height\n\t\t\t\t),\n\t\t\t})\n\t\t);\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\t// ImageBuddyUtil.debugTable(scoredSizes);\n\n\t\tconst idealImage = scoredSizes[scoredSizes.length - 1];\n\n\t\t// ImageBuddyUtil.debug(idealImage);\n\n\t\tif (compareURLs(this.el.getAttribute('src') || '', idealImage.url)) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst loadedImageURL = await loadImage(idealImage.url);\n\n\t\t\tif (this.el.tagName.toLowerCase() === 'img') {\n\t\t\t\tthis.el.setAttribute('src', loadedImageURL);\n\t\t\t} else {\n\t\t\t\tthis.el.style.backgroundImage = `url('${loadedImageURL}')`;\n\t\t\t}\n\n\t\t\tthis.loaded = true;\n\t\t\tthis.isLoading = false;\n\t\t\tthis.currentSize = {\n\t\t\t\twidth: idealImage.width,\n\t\t\t\theight: idealImage.height,\n\t\t\t};\n\t\t\tthis.el.classList.remove(this.config.classes.loading);\n\t\t\tthis.el.classList.add(this.config.classes.loaded);\n\n\t\t\tImageBuddyEvents.emit('image-loaded', this.el);\n\t\t} catch {\n\t\t\tconsole.error('error loading image', idealImage.url);\n\t\t}\n\t}\n\n\t/**\n\t * Check if an element is visible\n\t */\n\tisHidden(): boolean {\n\t\treturn this.el.offsetParent === null;\n\t}\n}\n","import ImageBuddyDebug from './ImageBuddyDebug';\nimport ImageBuddyDOMElement from './ImageBuddyDOMElement';\nimport ImageBuddyEvents from './ImageBuddyEvents';\nimport { elementIsCached, shouldIgnoreElement, getContainerDimensions } from './DOMUtil';\nimport {\n\tImageBuddyOpts,\n\tImageBuddyElements,\n\tImageBuddyUpdateOptions,\n\tImageBuddyConfig,\n\tIThrottleEventListenerOptions,\n} from './interfaces/index';\n\nclass ImageBuddy {\n\teventsRunning: any;\n\telements: ImageBuddyElements;\n\tconfig: ImageBuddyConfig;\n\topts: ImageBuddyOpts;\n\tdebugger: ImageBuddyDebug;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param {object} opts\n\t */\n\tconstructor(opts: Partial<ImageBuddyOpts>) {\n\t\tthis.eventsRunning = {};\n\t\tthis.elements = {\n\t\t\tqueue: [],\n\t\t\tloaded: [],\n\t\t};\n\n\t\tthis.config = {\n\t\t\tevents: {\n\t\t\t\tresize: 'ImageBuddyResize',\n\t\t\t\tscroll: 'ImageBuddyScroll',\n\t\t\t},\n\t\t\tattributes: {\n\t\t\t\t// enabled: 'data-ib-enabled',\n\t\t\t\tsources: 'data-ib-sources',\n\t\t\t\tlazyLoad: 'data-ib-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-ib-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-ib-match-dpr',\n\t\t\t\tnoHeight: 'data-ib-no-height',\n\t\t\t\tignoreHiddenCheck: 'data-ib-ignore-hidden-check',\n\t\t\t},\n\t\t\tclasses: {\n\t\t\t\tbase: 'ib__image',\n\t\t\t\tloading: 'ib__image--loading',\n\t\t\t\tloaded: 'ib__image--loaded',\n\t\t\t},\n\t\t};\n\n\t\t// create default options and merge any overrides\n\n\t\t// this.opts = Object.assign(\n\t\t// \t{\n\t\t// \t\tdebug: false,\n\t\t// \t\tmatchDPR: true,\n\t\t// \t\tlazyLoad: true,\n\t\t// \t\tlazyLoadThreshold: 100,\n\t\t// \t},\n\t\t// \topts\n\t\t// );\n\n\t\tthis.opts = {\n\t\t\tdebug: false,\n\t\t\tmatchDPR: true,\n\t\t\tlazyLoad: true,\n\t\t\tlazyLoadThreshold: 100,\n\t\t\t...opts,\n\t\t};\n\n\t\tthis.debugger = new ImageBuddyDebug(this.opts.debug);\n\n\t\tthis.setupEventListeners();\n\t\tthis.update();\n\t}\n\n\tprocessElementQueue() {\n\t\tlet numProcessed = 0;\n\n\t\tif (!this.elements.queue.length) {\n\t\t\treturn numProcessed;\n\t\t}\n\n\t\tfor (let i = 0; i < this.elements.queue.length; i++) {\n\t\t\tconst item = this.elements.queue[i];\n\n\t\t\tif (item.options.lazyLoad && item.canLazyLoad() === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem.chooseImage();\n\n\t\t\t// move to loaded array\n\t\t\tthis.elements.queue.splice(i, 1);\n\t\t\tthis.elements.loaded.push(item);\n\n\t\t\ti--;\n\n\t\t\tnumProcessed++;\n\t\t}\n\n\t\treturn numProcessed;\n\t}\n\n\tupdate(opts: ImageBuddyUpdateOptions = {}) {\n\t\tconst t1 = performance.now();\n\n\t\tconst parentEl = opts.parentEl || document.documentElement;\n\t\tconst newElements = this.getElements(parentEl);\n\t\tconst updateOffsetTop = opts.updateOffsetTop || false;\n\n\t\tthis.elements.queue = this.elements.queue.concat(newElements);\n\t\tthis.debugger.debugInfo(this.elements.queue);\n\n\t\tif (updateOffsetTop) {\n\t\t\tfor (let i = 0; i < this.elements.queue.length; i++) {\n\t\t\t\tthis.elements.queue[i].updateTopOffset();\n\t\t\t}\n\t\t}\n\n\t\tconst numProcessed = this.processElementQueue();\n\t\tconst t2 = performance.now();\n\n\t\tthis.debugger.debug('ImageBuddy: update complete', `${numProcessed} elements`, `${Math.round(t2 - t1)}ms`);\n\n\t\tImageBuddyEvents.emit('update');\n\t}\n\n\t/**\n\t * Setup and throttle event listeners -- scroll & resize\n\t */\n\tsetupEventListeners() {\n\t\tthis.throttleEventListener('resize', this.resizeHandler, {\n\t\t\tpassive: true,\n\t\t});\n\t\tthis.throttleEventListener('scroll', this.scrollHandler, {\n\t\t\tpassive: true,\n\t\t});\n\t}\n\n\t/**\n\t * Get all the HTML elements configured for image selection\n\t */\n\tgetElements(parentEl: HTMLElement) {\n\t\tconst elements = [];\n\t\tconst foundEls = parentEl.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (let i = 0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\t\t\t// const offsetTop = el.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop);\n\n\t\t\t// attribute that can be used to ignore specific images when loading\n\t\t\tif (elementIsCached(el) || shouldIgnoreElement(el)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telements.push(new ImageBuddyDOMElement(el as HTMLElement, this.config, this.opts));\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Resize handler\n\t */\n\tresizeHandler = () => {\n\t\t// cycle through loaded images and see if we need to select a different source\n\t\tfor (let i = 0; i < this.elements.loaded.length; i++) {\n\t\t\tconst item = this.elements.loaded[i];\n\t\t\tconst dimensions = getContainerDimensions(item.el, item.options.noHeight);\n\n\t\t\tif (\n\t\t\t\tdimensions.width > item.currentSize.width ||\n\t\t\t\t(!item.options.noHeight && dimensions.height > item.currentSize.height)\n\t\t\t) {\n\t\t\t\tthis.debugger.debug('swapping image');\n\t\t\t\titem.chooseImage();\n\t\t\t}\n\t\t}\n\n\t\t// re-calculate top offsets for images in the queue\n\t\tfor (let i = 0; i < this.elements.queue.length; i++) {\n\t\t\tthis.elements.queue[i].updateTopOffset();\n\t\t}\n\n\t\t// load any unprocessed cache elements\n\t\tthis.processElementQueue();\n\t};\n\n\t/**\n\t * Scroll handler -- check for lazy load-able images\n\t */\n\tscrollHandler = () => {\n\t\t// lazy load images\n\t\tthis.processElementQueue();\n\t};\n\n\t/**\n\t * Setup a throttled event listener\n\t *\n\t * @param {string} name\n\t * @param {function} callback\n\t * @param {object} options\n\t */\n\tthrottleEventListener(\n\t\teventName: string,\n\t\tcallback: EventListenerOrEventListenerObject,\n\t\tuserOptions: IThrottleEventListenerOptions\n\t) {\n\t\tconst passiveSupported = this.passiveEventListenerSupported();\n\n\t\tconst options = Object.assign(userOptions, {\n\t\t\tpassive: typeof userOptions.passive === 'undefined' ? true : userOptions.passive,\n\t\t\tcapture: typeof userOptions.capture === 'undefined' ? false : userOptions.capture,\n\t\t});\n\n\t\tif (!this.eventsRunning) {\n\t\t\tthis.eventsRunning = {};\n\t\t}\n\n\t\tconst eventIsRunning = Object.prototype.hasOwnProperty.call(this.eventsRunning, eventName);\n\n\t\tif (!eventIsRunning) {\n\t\t\tthis.eventsRunning[eventName] = false;\n\t\t}\n\n\t\twindow.addEventListener(\n\t\t\teventName,\n\t\t\t() => {\n\t\t\t\tif (this.eventsRunning[eventName]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.eventsRunning[eventName] = true;\n\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\twindow.dispatchEvent(new CustomEvent(`${eventName}-throttled`));\n\t\t\t\t\tthis.eventsRunning[eventName] = false;\n\t\t\t\t});\n\t\t\t},\n\t\t\tpassiveSupported ? options : options.capture\n\t\t);\n\n\t\tif (typeof callback === 'function') {\n\t\t\twindow.addEventListener(`${eventName}-throttled`, callback, passiveSupported ? options : options.capture);\n\t\t}\n\t}\n\n\tpassiveEventListenerSupported() {\n\t\t// check for passive event listener support\n\t\tlet passiveSupported = false;\n\n\t\ttry {\n\t\t\tconst options = Object.defineProperty({}, 'passive', {\n\t\t\t\tget() {\n\t\t\t\t\tpassiveSupported = true;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\twindow.addEventListener('test', () => {}, options);\n\t\t} catch (err) {}\n\n\t\treturn passiveSupported;\n\t}\n\n\tstatic on(event: string, listener: CallableFunction) {\n\t\tImageBuddyEvents.on(event, listener);\n\t}\n}\n\nexport default ImageBuddy;\n"],"names":["enabled","this","debug","console","log","debugInfo","info","debugTable","table","events","on","event","listener","push","emit","eventArgs","setTimeout","listeners","slice","i","length","apply","stringToBoolean","attrVal","refVal","trim","toLowerCase","parseInt","getPageYOffset","window","pageYOffset","document","scrollingElement","documentElement","scrollTop","calculateElementTopOffset","el","getBoundingClientRect","top","getSizesFromAttribute","rImgSources","split","map","sizeEl","height","url","width","sort","a","b","elementIsCached","hasAttribute","getAttribute","shouldIgnoreElement","getContainerDimensions","noHeight","container","style","display","getComputedStyle","clientWidth","clientHeight","parentElement","getElementWidth","ibConfig","ibOpts","classList","add","classes","base","setAttribute","Math","random","toString","substring","config","elType","tagName","sizes","attributes","sources","currentSize","loaded","isLoading","options","lazyLoad","lazyLoadThreshold","matchDPR","ignoreHiddenCheck","offsetTop","updateTopOffset","canLazyLoad","innerHeight","chooseImage","_this2","isHidden","devicePixelRatio","scoredSizes","size","Object","assign","score","containerWidth","containerHeight","imageWidth","imageHeight","abs","idealImage","testUrls","anchor","createElement","href","host","pathname","imageURL","Promise","resolve","reject","imageLoader","Image","onload","src","onerror","loadedImageURL","backgroundImage","remove","loading","ImageBuddyEvents","error","offsetParent","ImageBuddy","opts","_this","elements","item","dimensions","debugger","queue","processElementQueue","eventsRunning","resize","scroll","ImageBuddyDebug","setupEventListeners","update","numProcessed","splice","t1","performance","now","parentEl","newElements","getElements","updateOffsetTop","concat","t2","round","throttleEventListener","resizeHandler","passive","scrollHandler","foundEls","querySelectorAll","ImageBuddyDOMElement","eventName","callback","userOptions","passiveSupported","passiveEventListenerSupported","capture","prototype","hasOwnProperty","call","addEventListener","requestAnimationFrame","dispatchEvent","CustomEvent","defineProperty","get","err"],"mappings":"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"}