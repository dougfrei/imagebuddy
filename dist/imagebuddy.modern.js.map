{"version":3,"file":"imagebuddy.modern.js","sources":["../source/ImageBuddyDebug.ts","../source/ImageBuddyEvents.ts","../source/ImageBuddyUtil.ts","../source/DOMUtil.ts","../source/ImageBuddyDOMElement.ts","../source/ImageBuddy.ts"],"sourcesContent":["export default class {\n\tenabled: boolean;\n\n\tconstructor(enabled = false) {\n\t\tthis.enabled = enabled;\n\t}\n\n\tdebug(...args: any[]) {\n\t\tif (this.enabled) {\n\t\t\tconsole.log(...args);\n\t\t}\n\t}\n\n\tdebugInfo(...args: any[]) {\n\t\tif (this.enabled) {\n\t\t\tconsole.info(...args);\n\t\t}\n\t}\n\n\tdebugTable(...args: any[]) {\n\t\tif (this.enabled) {\n\t\t\tconsole.table(...args);\n\t\t}\n\t}\n}\n","const events: any = {};\n\nexport default class {\n\tstatic on(event: string, listener: CallableFunction) {\n\t\tif (typeof events[event] !== 'object') {\n\t\t\tevents[event] = [];\n\t\t}\n\n\t\tevents[event].push(listener);\n\t}\n\n\tstatic emit(event: string, ...args: any[]) {\n\t\tconst eventArgs = args;\n\n\t\t// allow handlers to register themselves before executing\n\t\tsetTimeout(() => {\n\t\t\tif (typeof events[event] === 'object') {\n\t\t\t\tconst listeners = events[event].slice();\n\n\t\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\t\tlisteners[i].apply(null, eventArgs);\n\t\t\t\t}\n\t\t\t}\n\t\t}, 0);\n\t}\n}\n","export function stringToBoolean(attrVal: string): boolean {\n\tconst refVal = attrVal.trim().toLowerCase();\n\n\tif (refVal === 'true') {\n\t\treturn true;\n\t}\n\n\tif (refVal === 'false') {\n\t\treturn false;\n\t}\n\n\tconst numVal = parseInt(refVal, 10);\n\n\treturn numVal > 0;\n}\n","import { ImageSource, ImageSize } from './interfaces/index';\n\nexport function getPageYOffset(): number {\n\tif (typeof window.pageYOffset !== 'undefined') {\n\t\treturn window.pageYOffset;\n\t}\n\n\tconst scrollEl = document.scrollingElement || document.documentElement;\n\n\treturn scrollEl.scrollTop;\n}\n\nexport function calculateElementTopOffset(el: HTMLElement): number {\n\treturn el.getBoundingClientRect().top + getPageYOffset();\n}\n\n/**\n * Create an array of image sizes from the \"data-ib-sources\" attribute\n *\n * @param {string} rImgSources\n */\nexport function getSizesFromAttribute(rImgSources: string): ImageSource[] {\n\tif (!rImgSources.trim()) {\n\t\treturn [];\n\t}\n\n\treturn rImgSources\n\t\t.split(',')\n\t\t.map((sizeEl) => {\n\t\t\tconst [url, width, height] = sizeEl.trim().split(' ');\n\n\t\t\treturn {\n\t\t\t\turl,\n\t\t\t\twidth: parseInt(width, 10),\n\t\t\t\theight: parseInt(height, 10)\n\t\t\t};\n\t\t})\n\t\t.sort((a, b) => {\n\t\t\tif (a.width >= a.height) {\n\t\t\t\treturn a.width > b.width ? 1 : -1;\n\t\t\t}\n\n\t\t\treturn a.height > b.height ? 1 : -1;\n\t\t});\n}\n\nexport function elementIsCached(el: Element): boolean {\n\tif (!el) {\n\t\treturn false;\n\t}\n\n\tif (el.hasAttribute('data-ib-no-cache')) {\n\t\treturn false;\n\t}\n\n\tif (el.getAttribute('data-ib-cache-id')) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function shouldIgnoreElement(el: Element) {\n\treturn el.hasAttribute('data-ib-ignore');\n}\n\nexport function calculateUsabilityScore(containerWidth: number, containerHeight: number, imageWidth: number, imageHeight: number): number {\n\t// ImageBuddyUtil.debug(`container: ${containerWidth}x${containerHeight}`, `image: ${imageWidth}x${imageHeight}`);\n\n\tlet score = 1;\n\n\tif (imageWidth >= containerWidth) {\n\t\tscore *= containerWidth / imageWidth;\n\t} else {\n\t\tscore -= Math.abs(containerWidth - imageWidth);\n\t}\n\n\tif (containerHeight) {\n\t\tif (imageHeight >= containerHeight) {\n\t\t\tscore *= containerHeight / imageHeight;\n\t\t} else {\n\t\t\tscore -= Math.abs(containerHeight - imageHeight);\n\t\t}\n\t}\n\n\treturn score;\n}\n\n/**\n * Return the width of a tested element\n * This will examine a style attribute tag first and fallback to the computed style\n *\n * @param {object} el\n */\nexport function getElementWidth(el: HTMLElement): number {\n\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\tif (displayStyle !== 'block' && el.parentElement) {\n\t\treturn getElementWidth(el.parentElement);\n\t}\n\n\treturn el.clientWidth;\n}\n\n/**\n * Get container dimensions of an HTML element\n *\n * @param {object} el\n * @param {bool} noHeight\n */\nexport function getContainerDimensions(el: HTMLElement, noHeight = false): ImageSize {\n\t// FIXME:\n\t// this is tricky since an IMG tag may not have a set height and we can't rely on\n\t// its container for that height value\n\t// I'm thinking the best way to tackle this is to see if the element has a height\n\t// specified -- if not we'll disregard the height value\n\t//      - how does a 100% height work with this?\n\n\t// el.clientHeight works fine on all tags except IMG\n\n\tconst displayStyle = el.style.display ? el.style.display : window.getComputedStyle(el).display;\n\n\tconst container = {\n\t\twidth: (displayStyle === 'block') ? el.clientWidth : 0,\n\t\theight: el.clientHeight ? el.clientHeight : 0 // TODO: try `parseInt(window.getComputedStyle(el).height)` here\n\t};\n\n\tif (!container.width && el.parentElement) {\n\t\tcontainer.width = getElementWidth(el.parentElement);\n\t}\n\n\tif (noHeight) {\n\t\tcontainer.height = 0;\n\t}\n\n\treturn container;\n}\n\n/**\n * Creates a dummy image element and loads the requested image URL\n * Returns a promise with the loaded image URL\n *\n * @param imageURL the image URL to load\n */\nexport function loadImage(imageURL: string): Promise<string> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst imageLoader = new Image();\n\n\t\timageLoader.onload = () => {\n\t\t\tresolve(imageLoader.src);\n\t\t};\n\n\t\timageLoader.onerror = () => {\n\t\t\treject(imageLoader.src);\n\t\t}\n\n\t\timageLoader.src = imageURL;\n\t});\n}\n\nexport function compareURLs(url1: string, url2: string): boolean {\n\tconst testUrls = [url1, url2].map(url => {\n\t\tconst anchor = document.createElement('a');\n\n\t\tanchor.href = url.toLowerCase();\n\n\t\treturn anchor.host + anchor.pathname;\n\t});\n\n\treturn testUrls[0] === testUrls[1];\n}\n","import ImageBuddyEvents from './ImageBuddyEvents';\nimport { stringToBoolean } from './ImageBuddyUtil';\nimport {\n\tcalculateElementTopOffset,\n\tgetSizesFromAttribute,\n\tcalculateUsabilityScore,\n\tgetElementWidth,\n\tgetContainerDimensions,\n\tloadImage,\n\tgetPageYOffset,\n\tcompareURLs,\n} from './DOMUtil';\nimport {\n\tImageSource,\n\tImageSize,\n\tImageBuddyDOMElementOptions,\n\tImageBuddyConfig,\n\tImageBuddyOpts,\n} from './interfaces/index';\n\nexport default class {\n\tel: HTMLElement;\n\tconfig: ImageBuddyConfig;\n\telType: string;\n\tsizes: ImageSource[];\n\tcurrentSize: ImageSize;\n\tloaded: boolean;\n\tisLoading: boolean;\n\toptions: ImageBuddyDOMElementOptions;\n\toffsetTop: number;\n\n\tconstructor(\n\t\tel: HTMLElement,\n\t\tibConfig: ImageBuddyConfig,\n\t\tibOpts: ImageBuddyOpts\n\t) {\n\t\tel.classList.add(ibConfig.classes.base);\n\t\tel.setAttribute(\n\t\t\t'data-ib-cache-id',\n\t\t\tMath.random().toString(36).substring(7)\n\t\t);\n\n\t\tthis.el = el;\n\t\tthis.config = ibConfig;\n\n\t\tthis.elType = el.tagName.toLowerCase();\n\t\tthis.sizes = getSizesFromAttribute(\n\t\t\tel.getAttribute(ibConfig.attributes.sources) || ''\n\t\t);\n\t\tthis.currentSize = { width: 0, height: 0 };\n\t\tthis.loaded = false; // FIXME: figure out a way to check if images are already loaded when this array is created\n\t\tthis.isLoading = false;\n\t\tthis.options = {\n\t\t\tlazyLoad: el.hasAttribute(ibConfig.attributes.lazyLoad)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(ibConfig.attributes.lazyLoad) || ''\n\t\t\t\t  )\n\t\t\t\t: ibOpts.lazyLoad,\n\t\t\tlazyLoadThreshold: el.hasAttribute(\n\t\t\t\tibConfig.attributes.lazyLoadThreshold\n\t\t\t)\n\t\t\t\t? parseInt(\n\t\t\t\t\t\tel.getAttribute(\n\t\t\t\t\t\t\tibConfig.attributes.lazyLoadThreshold\n\t\t\t\t\t\t) || '0',\n\t\t\t\t\t\t10\n\t\t\t\t  )\n\t\t\t\t: ibOpts.lazyLoadThreshold,\n\t\t\tmatchDPR: el.hasAttribute(ibConfig.attributes.matchDPR)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(ibConfig.attributes.matchDPR) || ''\n\t\t\t\t  )\n\t\t\t\t: ibOpts.matchDPR,\n\t\t\tnoHeight: el.hasAttribute(ibConfig.attributes.noHeight)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(ibConfig.attributes.noHeight) || ''\n\t\t\t\t  )\n\t\t\t\t: false,\n\t\t\tignoreHiddenCheck: el.hasAttribute(\n\t\t\t\tibConfig.attributes.ignoreHiddenCheck\n\t\t\t)\n\t\t\t\t? stringToBoolean(\n\t\t\t\t\t\tel.getAttribute(\n\t\t\t\t\t\t\tibConfig.attributes.ignoreHiddenCheck\n\t\t\t\t\t\t) || ''\n\t\t\t\t  )\n\t\t\t\t: false,\n\t\t};\n\t\tthis.offsetTop = calculateElementTopOffset(this.el);\n\t}\n\n\tupdateTopOffset() {\n\t\tthis.offsetTop = calculateElementTopOffset(this.el);\n\t}\n\n\t/**\n\t * Test if an item is lazy load-able\n\t *\n\t * @param {object} item\n\t */\n\tcanLazyLoad(): boolean {\n\t\tif (!this.options.lazyLoad || this.loaded) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.offsetTop - (getPageYOffset() + window.innerHeight) <=\n\t\t\tthis.options.lazyLoadThreshold\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Choose the appropriate image and apply it to the element\n\t *\n\t * @param {object} item\n\t */\n\tasync chooseImage() {\n\t\tif (this.isLoading) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.options.ignoreHiddenCheck && this.isHidden()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.isLoading = true;\n\n\t\tconst sizes = getSizesFromAttribute(\n\t\t\tthis.el.getAttribute(this.config.attributes.sources) || ''\n\t\t);\n\t\tconst elType = this.el.tagName.toLowerCase();\n\n\t\tif (\n\t\t\telType === 'img' &&\n\t\t\tparseInt(getComputedStyle(this.el).width || '0', 10) <= 1\n\t\t) {\n\t\t\tthis.el.style.width = '100%';\n\t\t}\n\n\t\tconst container = getContainerDimensions(\n\t\t\tthis.el,\n\t\t\tthis.options.noHeight\n\t\t);\n\n\t\tif (this.options.matchDPR) {\n\t\t\tcontainer.width *= window.devicePixelRatio;\n\t\t\tcontainer.height *= window.devicePixelRatio;\n\t\t}\n\n\t\tconst scoredSizes = sizes.map((size) =>\n\t\t\tObject.assign(size, {\n\t\t\t\tscore: calculateUsabilityScore(\n\t\t\t\t\tcontainer.width,\n\t\t\t\t\tcontainer.height,\n\t\t\t\t\tsize.width,\n\t\t\t\t\tsize.height\n\t\t\t\t),\n\t\t\t})\n\t\t);\n\n\t\tscoredSizes.sort((a, b) => a.score - b.score);\n\n\t\t// ImageBuddyUtil.debugTable(scoredSizes);\n\n\t\tconst idealImage = scoredSizes[scoredSizes.length - 1];\n\n\t\t// ImageBuddyUtil.debug(idealImage);\n\n\t\tif (compareURLs(this.el.getAttribute('src') || '', idealImage.url)) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst loadedImageURL = await loadImage(idealImage.url);\n\n\t\t\tif (this.el.tagName.toLowerCase() === 'img') {\n\t\t\t\tthis.el.setAttribute('src', loadedImageURL);\n\t\t\t} else {\n\t\t\t\tthis.el.style.backgroundImage = `url('${loadedImageURL}')`;\n\t\t\t}\n\n\t\t\tthis.loaded = true;\n\t\t\tthis.isLoading = false;\n\t\t\tthis.currentSize = {\n\t\t\t\twidth: idealImage.width,\n\t\t\t\theight: idealImage.height,\n\t\t\t};\n\t\t\tthis.el.classList.remove(this.config.classes.loading);\n\t\t\tthis.el.classList.add(this.config.classes.loaded);\n\n\t\t\tImageBuddyEvents.emit('image-loaded', this.el);\n\t\t} catch {\n\t\t\tconsole.error('error loading image', idealImage.url);\n\t\t}\n\t}\n\n\t/**\n\t * Check if an element is visible\n\t */\n\tisHidden(): boolean {\n\t\treturn this.el.offsetParent === null;\n\t}\n}\n","import ImageBuddyDebug from './ImageBuddyDebug';\nimport ImageBuddyDOMElement from './ImageBuddyDOMElement';\nimport ImageBuddyEvents from './ImageBuddyEvents';\nimport { elementIsCached, shouldIgnoreElement, getContainerDimensions } from './DOMUtil';\nimport {\n\tImageBuddyOpts,\n\tImageBuddyElements,\n\tImageBuddyUpdateOptions,\n\tImageBuddyConfig,\n\tIThrottleEventListenerOptions,\n} from './interfaces/index';\n\nclass ImageBuddy {\n\teventsRunning: any;\n\telements: ImageBuddyElements;\n\tconfig: ImageBuddyConfig;\n\topts: ImageBuddyOpts;\n\tdebugger: ImageBuddyDebug;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param {object} opts\n\t */\n\tconstructor(opts: Partial<ImageBuddyOpts>) {\n\t\tthis.eventsRunning = {};\n\t\tthis.elements = {\n\t\t\tqueue: [],\n\t\t\tloaded: [],\n\t\t};\n\n\t\tthis.config = {\n\t\t\tevents: {\n\t\t\t\tresize: 'ImageBuddyResize',\n\t\t\t\tscroll: 'ImageBuddyScroll',\n\t\t\t},\n\t\t\tattributes: {\n\t\t\t\t// enabled: 'data-ib-enabled',\n\t\t\t\tsources: 'data-ib-sources',\n\t\t\t\tlazyLoad: 'data-ib-lazyload',\n\t\t\t\tlazyLoadThreshold: 'data-ib-lazyload-threshold',\n\t\t\t\tmatchDPR: 'data-ib-match-dpr',\n\t\t\t\tnoHeight: 'data-ib-no-height',\n\t\t\t\tignoreHiddenCheck: 'data-ib-ignore-hidden-check',\n\t\t\t},\n\t\t\tclasses: {\n\t\t\t\tbase: 'ib__image',\n\t\t\t\tloading: 'ib__image--loading',\n\t\t\t\tloaded: 'ib__image--loaded',\n\t\t\t},\n\t\t};\n\n\t\t// create default options and merge any overrides\n\n\t\t// this.opts = Object.assign(\n\t\t// \t{\n\t\t// \t\tdebug: false,\n\t\t// \t\tmatchDPR: true,\n\t\t// \t\tlazyLoad: true,\n\t\t// \t\tlazyLoadThreshold: 100,\n\t\t// \t},\n\t\t// \topts\n\t\t// );\n\n\t\tthis.opts = {\n\t\t\tdebug: false,\n\t\t\tmatchDPR: true,\n\t\t\tlazyLoad: true,\n\t\t\tlazyLoadThreshold: 100,\n\t\t\t...opts,\n\t\t};\n\n\t\tthis.debugger = new ImageBuddyDebug(this.opts.debug);\n\n\t\tthis.setupEventListeners();\n\t\tthis.update();\n\t}\n\n\tprocessElementQueue() {\n\t\tlet numProcessed = 0;\n\n\t\tif (!this.elements.queue.length) {\n\t\t\treturn numProcessed;\n\t\t}\n\n\t\tfor (let i = 0; i < this.elements.queue.length; i++) {\n\t\t\tconst item = this.elements.queue[i];\n\n\t\t\tif (item.options.lazyLoad && item.canLazyLoad() === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem.chooseImage();\n\n\t\t\t// move to loaded array\n\t\t\tthis.elements.queue.splice(i, 1);\n\t\t\tthis.elements.loaded.push(item);\n\n\t\t\ti--;\n\n\t\t\tnumProcessed++;\n\t\t}\n\n\t\treturn numProcessed;\n\t}\n\n\tupdate(opts: ImageBuddyUpdateOptions = {}) {\n\t\tconst t1 = performance.now();\n\n\t\tconst parentEl = opts.parentEl || document.documentElement;\n\t\tconst newElements = this.getElements(parentEl);\n\t\tconst updateOffsetTop = opts.updateOffsetTop || false;\n\n\t\tthis.elements.queue = this.elements.queue.concat(newElements);\n\t\tthis.debugger.debugInfo(this.elements.queue);\n\n\t\tif (updateOffsetTop) {\n\t\t\tfor (let i = 0; i < this.elements.queue.length; i++) {\n\t\t\t\tthis.elements.queue[i].updateTopOffset();\n\t\t\t}\n\t\t}\n\n\t\tconst numProcessed = this.processElementQueue();\n\t\tconst t2 = performance.now();\n\n\t\tthis.debugger.debug('ImageBuddy: update complete', `${numProcessed} elements`, `${Math.round(t2 - t1)}ms`);\n\n\t\tImageBuddyEvents.emit('update');\n\t}\n\n\t/**\n\t * Setup and throttle event listeners -- scroll & resize\n\t */\n\tsetupEventListeners() {\n\t\tthis.throttleEventListener('resize', this.resizeHandler, {\n\t\t\tpassive: true,\n\t\t});\n\t\tthis.throttleEventListener('scroll', this.scrollHandler, {\n\t\t\tpassive: true,\n\t\t});\n\t}\n\n\t/**\n\t * Get all the HTML elements configured for image selection\n\t */\n\tgetElements(parentEl: HTMLElement) {\n\t\tconst elements = [];\n\t\tconst foundEls = parentEl.querySelectorAll(`[${this.config.attributes.sources}]`);\n\n\t\tfor (let i = 0; i < foundEls.length; i++) {\n\t\t\tconst el = foundEls[i];\n\t\t\t// const offsetTop = el.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop);\n\n\t\t\t// attribute that can be used to ignore specific images when loading\n\t\t\tif (elementIsCached(el) || shouldIgnoreElement(el)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telements.push(new ImageBuddyDOMElement(el as HTMLElement, this.config, this.opts));\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Resize handler\n\t */\n\tresizeHandler = () => {\n\t\t// cycle through loaded images and see if we need to select a different source\n\t\tfor (let i = 0; i < this.elements.loaded.length; i++) {\n\t\t\tconst item = this.elements.loaded[i];\n\t\t\tconst dimensions = getContainerDimensions(item.el, item.options.noHeight);\n\n\t\t\tif (\n\t\t\t\tdimensions.width > item.currentSize.width ||\n\t\t\t\t(!item.options.noHeight && dimensions.height > item.currentSize.height)\n\t\t\t) {\n\t\t\t\tthis.debugger.debug('swapping image');\n\t\t\t\titem.chooseImage();\n\t\t\t}\n\t\t}\n\n\t\t// re-calculate top offsets for images in the queue\n\t\tfor (let i = 0; i < this.elements.queue.length; i++) {\n\t\t\tthis.elements.queue[i].updateTopOffset();\n\t\t}\n\n\t\t// load any unprocessed cache elements\n\t\tthis.processElementQueue();\n\t};\n\n\t/**\n\t * Scroll handler -- check for lazy load-able images\n\t */\n\tscrollHandler = () => {\n\t\t// lazy load images\n\t\tthis.processElementQueue();\n\t};\n\n\t/**\n\t * Setup a throttled event listener\n\t *\n\t * @param {string} name\n\t * @param {function} callback\n\t * @param {object} options\n\t */\n\tthrottleEventListener(\n\t\teventName: string,\n\t\tcallback: EventListenerOrEventListenerObject,\n\t\tuserOptions: IThrottleEventListenerOptions\n\t) {\n\t\tconst passiveSupported = this.passiveEventListenerSupported();\n\n\t\tconst options = Object.assign(userOptions, {\n\t\t\tpassive: typeof userOptions.passive === 'undefined' ? true : userOptions.passive,\n\t\t\tcapture: typeof userOptions.capture === 'undefined' ? false : userOptions.capture,\n\t\t});\n\n\t\tif (!this.eventsRunning) {\n\t\t\tthis.eventsRunning = {};\n\t\t}\n\n\t\tconst eventIsRunning = Object.prototype.hasOwnProperty.call(this.eventsRunning, eventName);\n\n\t\tif (!eventIsRunning) {\n\t\t\tthis.eventsRunning[eventName] = false;\n\t\t}\n\n\t\twindow.addEventListener(\n\t\t\teventName,\n\t\t\t() => {\n\t\t\t\tif (this.eventsRunning[eventName]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.eventsRunning[eventName] = true;\n\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\twindow.dispatchEvent(new CustomEvent(`${eventName}-throttled`));\n\t\t\t\t\tthis.eventsRunning[eventName] = false;\n\t\t\t\t});\n\t\t\t},\n\t\t\tpassiveSupported ? options : options.capture\n\t\t);\n\n\t\tif (typeof callback === 'function') {\n\t\t\twindow.addEventListener(`${eventName}-throttled`, callback, passiveSupported ? options : options.capture);\n\t\t}\n\t}\n\n\tpassiveEventListenerSupported() {\n\t\t// check for passive event listener support\n\t\tlet passiveSupported = false;\n\n\t\ttry {\n\t\t\tconst options = Object.defineProperty({}, 'passive', {\n\t\t\t\tget() {\n\t\t\t\t\tpassiveSupported = true;\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\twindow.addEventListener('test', () => {}, options);\n\t\t} catch (err) {}\n\n\t\treturn passiveSupported;\n\t}\n\n\tstatic on(event: string, listener: CallableFunction) {\n\t\tImageBuddyEvents.on(event, listener);\n\t}\n}\n\nexport default ImageBuddy;\n"],"names":["constructor","enabled","this","debug","args","console","log","debugInfo","info","debugTable","table","events","[object Object]","event","listener","push","eventArgs","setTimeout","listeners","slice","i","length","apply","stringToBoolean","attrVal","refVal","trim","toLowerCase","parseInt","getPageYOffset","window","pageYOffset","document","scrollingElement","documentElement","scrollTop","calculateElementTopOffset","el","getBoundingClientRect","top","getSizesFromAttribute","rImgSources","split","map","sizeEl","url","width","height","sort","a","b","elementIsCached","hasAttribute","getAttribute","shouldIgnoreElement","calculateUsabilityScore","containerWidth","containerHeight","imageWidth","imageHeight","score","Math","abs","getContainerDimensions","noHeight","container","style","display","getComputedStyle","clientWidth","clientHeight","parentElement","getElementWidth","ibConfig","ibOpts","classList","add","classes","base","setAttribute","random","toString","substring","config","elType","tagName","sizes","attributes","sources","currentSize","loaded","isLoading","options","lazyLoad","lazyLoadThreshold","matchDPR","ignoreHiddenCheck","offsetTop","updateTopOffset","canLazyLoad","innerHeight","isHidden","devicePixelRatio","scoredSizes","size","Object","assign","idealImage","imageURL","url1","url2","testUrls","anchor","createElement","href","host","pathname","compareURLs","loadedImageURL","Promise","resolve","reject","imageLoader","Image","onload","src","onerror","backgroundImage","remove","loading","ImageBuddyEvents","emit","error","offsetParent","opts","elements","item","dimensions","debugger","chooseImage","queue","processElementQueue","eventsRunning","resize","scroll","ImageBuddyDebug","setupEventListeners","update","numProcessed","splice","t1","performance","now","parentEl","newElements","getElements","updateOffsetTop","concat","t2","round","throttleEventListener","resizeHandler","passive","scrollHandler","foundEls","querySelectorAll","ImageBuddyDOMElement","eventName","callback","userOptions","passiveSupported","passiveEventListenerSupported","capture","prototype","hasOwnProperty","call","addEventListener","requestAnimationFrame","dispatchEvent","CustomEvent","defineProperty","get","err","on"],"mappings":"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"}